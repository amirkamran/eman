#!/usr/bin/env perl
# eman, experiment manager
#
# More info: 'eman --help' or 'eman --man'
#
# Ondřej Bojar, bojar@ufal.mff.cuni.cz
# Aleš Tamchyna, tamchyna@ufal.mff.cuni.cz
# Dan Zeman, zeman@ufal.mff.cuni.cz
#
# BUGS: now already excluding dir self name from hash,
#       should be also removing the exp's old name before renaming
#       should include env vars in vars when cloning from scenario
#       we need to find the equivalent for -CSAD to accept unicode
#       chars as arguments

use strict;
use warnings;
use 5.010;
use YAML::XS;
use File::Temp qw/tempfile/;
use Carp;
use Term::ANSIColor;
use Encode;
use Getopt::Long;
use Pod::Usage;
use File::Basename;
use File::Path;
use File::Spec;
use Cwd qw/cwd abs_path/;
use Digest::MD5 qw(md5_hex);
use Fcntl qw(LOCK_EX LOCK_NB);
# use File::NFSLock;
use FindBin qw($Bin);
use List::Util qw(min);
use List::MoreUtils qw(uniq);
my $eman = $Bin."/".basename($0); # full path to ourselves

binmode(STDIN, ":utf8");
binmode(STDOUT, ":utf8");
binmode(STDERR, ":utf8");

# command name abbreviations, identities provided for commands with no abbrevs
my %expand_abbrev = qw(
  retag retag
  tab tabulate
  ls list
  sel select
  cl clone
  tb traceback
  tr traceback
  tf traceforward
  traceusers traceforward
  tu traceforward
  to traceorigin
  td tracederivatives
  rm abolish
  st start
  pr prepare
  prep prepare
  stat status
  tag tag
  vars vars
  deps deps
  init init
  run run
  cont continue
  clean clean
  users users
  reindex reindex
  redo redo
  wait wait
  fail fail
  outdate outdate
  dups duplicates
  guess guess
  qstat qstat
  collect collect
  defvar defvar
  bash-loadvars bash-loadvars
  succeed succeed
  addtag add-tag
  adddep add-deps
  add-dep add-deps
  adddir add-dir
  addremote add-remote
  path path
  getvar get-var
  mkbln make-backlinks
  ann annotate
);
# all expanded names are also allowed:
foreach my $val (values %expand_abbrev) {
  $expand_abbrev{$val} = $val;
}

my $wait_sleep = 3;
my $startupwd = cwd();
my $debug = 0;
my $dryrun = 0;
my $reindex = 0;
my $verbose = 0;
my $manpage = 0;
my $help = 0;
my $colorize = undef; # surely colorize output
my $list_options = 0;
my $assume_abolished_ok = 0;
my $show_tag = 0;
my $show_vars = 0;
my $show_status = 0;
my $show_log = 0;
my $show_jobid = 0;
my $list_only_steps_with_no_users = 0;
my $show_disk_usage = 0;
my $print_created_step = 0; # for machine use of eman init/clone
my $recurse = 1; # in traceback; switched off when using vars -s
my $sge = 1;
my $do_start = 0;
my $do_wait = 0; # when started an experiment, wait for it to finish
my $do_outdate = 0;
my $notree = 0; # set to 1 to avoid tree (indented) output in eman traceback
my $add_tag = undef; # for newly inited steps, add the given tags
my $subst = undef;
my $substvar = undef;
my $appendvar = undef;
my $avoid = undef;
my $avoid_more = undef; # corresponds to --redo
my $reuse = undef;
my $ignore = undef; # like avoid but may include just steptype, not fully
                    # qualified steps
# Also used when cloning from a text recipe: we sometimes
# need to say that a step is already available where it actually it not but
# where we know the init phase of the depending step will solve it somehow.
# With corpman, this happens quite often when there are more ways to create a
# corpus. Cloning a traceback with exact steps leading to a corpus may fail
# beucase the corpus exists but it was created differently. So when cloning
# such a traceback, just --ignore=corpus.
my $avoid_all = 0;
my $readonly = 0; # don't save anything, e.g. when browsing sb. elses exps
$readonly = 1 if defined $ENV{"EMAN_READONLY"};
# standard filenames and filename parts
my $dirprefix = "s."; # stands for 'step'
my $indexfile = "eman.index";
my $resultsfile = "eman.results";
my $resultsconffile = "eman.results.conf";
my $seedsdir = "eman.seeds";
my $subdirs_file = "eman.subdirs";
my $maindir = undef; # the path of the directory with seeds, steps etc.
                     # guessed using chdir_to_maindir

my $qsub_available = undef;
my $hard_reindex = 1; # update the whole index
my $remote = 0; # do not list remote steps by default
my $showdir = 0; # show directory (alias) for remote steps

my %qsub_defaults = (
  mem => "6g", # memory requirements
  cores => 1,  # cpu cores
);

# qsub flags we interpret
my $queue = undef;
my $priority = -100; # use a lower priority by default
my $exclude_comp = undef; # exclude a single computer
my $mem = undef;
my $cores = undef;
my $disk = undef; # informative temp disk requirements
my $time = undef; # time limit
my @limits = ();  # other custom limits
my @userholds = (); # SGE jobids to wait for
# the 'environment' used to interpret qsub flags
my $env = "ufal"; # SGE environment (used for option mapping)
my $hostname = `hostname`;
my $anonymize = 0; # anonymize traceback
if ($hostname =~ /^cluster-cn-/i) {
  $env = "rwth";
}
my $subdir = "."; # the directory where to create the experiments

my %options = (
  "help|h" => \$help,
  "verbose|v" => \$verbose,
  "debug" => \$debug,
  "dry-run!" => \$dryrun,
     # note that dry runs are not quite reliable because seeds are allowed to
     # set default values of variables, so searching for a matching step works
     # differently for cases where the seed was run (real runs) or where it was
     # not run (dry runs)
  "list-options" => \$list_options,
  "man" => \$manpage,
  "sge!" => \$sge,
  "colorize!" => \$colorize,
  "assume-abolished-ok" => \$assume_abolished_ok, # for eman start
  "notree!" => \$notree,
  "tag!" => \$show_tag,
  "vars!" => \$show_vars,
  "status!" => \$show_status,
  "jobid!" => \$show_jobid,
  "log!" => \$show_log,
  "only-leaves|only-leafs!" => \$list_only_steps_with_no_users,
  "disk-usage|dus!" => \$show_disk_usage,
  "read-only|readonly!" => \$readonly,
  "s|substitute=s@" => \$subst,
  "sv|substitute-var=s@" => \$substvar,
  "av|append-var=s@" => \$appendvar,
  "avoid=s@" => \$avoid,
  "reuse=s@" => \$reuse,
  "redo=s@" => \$avoid_more,
  "ignore=s@" => \$ignore,
  "all-avoid!" => \$avoid_all,
  "add-tag|addtag=s@" => \$add_tag,
  "start!" => \$do_start,
  "wait!" => \$do_wait,
  "outdate!" => \$do_outdate,  # outdate the redone/cloned step (the *top* only)
  "print-created-step!" => \$print_created_step,
  "reindex" => \$reindex,
  "queue=s"=>\$queue,
  "priority=i"=>\$priority,
  "exclude-comp=s"=>\$exclude_comp,
  "mem:s"=>\$mem, # set e.g. to 10m or 4g; set to '' to run with no limits
    # but risk killing the machine
  "disk=s"=>\$disk, # format: 10g
  "time=s"=>\$time, # format: hh:mm:ss
  "cores=s"=>\$cores, # number of cores
  "limit|l=s@"=>\@limits, # format, e.g.: h_stack=30M
  "hold=s@"=>\@userholds, # format: 123456
  "subdir=s"=>\$subdir,
  "hard!" =>\$hard_reindex,
  "remote!" =>\$remote,
  "dir|show-dir!" =>\$showdir,
  "anonymize!" =>\$anonymize,
);
GetOptions(%options) or exit 1;

my $show_tree_in_traceback = ! $notree;

# interpret substvar VAR=x as subst /^VAR=.*/VAR=x/
foreach my $sv (@$substvar) {
  my $varname = $sv; $varname =~ s/=.*//;
  push @$subst, "/^$varname=.*/$sv/";
}
# interpret appendvar VAR=x as subst /^VAR=(.*)/VAR=$1x/
foreach my $av (@$appendvar) {
  my ($varname, $appendvalue) = split /=/, $av, 2;

  if ($appendvalue =~ /[" ]/) {
    # needed to escape
    $appendvalue =~ s/^"(.*)"$/$1/;
    push @$subst, "/^$varname=([^\"]*)/$varname=\":\$1$appendvalue\"/";
      # old did not need, but new value needs to escape
    push @$subst, "/^$varname=\"(.*)\"/$varname=\"\$1$appendvalue\"/";
      # old needs wrapping, so let's do it
  } else {
    push @$subst, "/^$varname=([^\"]*)/$varname=\$1$appendvalue/";
      # neither old nor new value need wrapping
    push @$subst, "/^$varname=\"(.*)\"/$varname=\"\$1$appendvalue\"/";
      # old needs wrapping, so let's do it
  }
}

# colorize regex outputs if substituting and output is terminal (or wished)
if ($colorize || (!defined $colorize && -t STDOUT)) {
  my $hicolor = color("on_yellow");
  my $uncolor = color("reset");
  $subst = [ map {s/([^\/])\//$1\/$hicolor/;
                  s/\/([^\/]*$)/$uncolor\/$1/; $_;} @$subst];
}

my $command = shift;
my $cmd = recognize_command($command);
my $waserror = 0;

sub mydie($) {
  my $msg = shift;
  print STDERR $msg."\n";
  exit 1;
}

if (defined $command && !defined $cmd) {
  print STDERR "Bad command: $command\n";
  $waserror = 1;
  $help = 1;
}


# Help and usage, inspired by btred by Petr Pajas
if ($manpage) {
### show manpage on console
#  pod2usage(-exitstatus => 0, -verbose => 99, -sections => '.*');
  pod2usage(-exitstatus => 0, -verbose => 2);
}
if ($help || !defined $command) {
  pod2usage(-msg => 'eman, experiment management');
  exit $waserror;
}
if ($list_options) {
  # show all possible command line options of eman
  foreach my $o (keys %options) {
    $o=~s/=.$//;
    foreach my $oo (split /\|/,$o) {
      print sort ((length($oo)>1) ? "--$oo\n" : "-$oo\n");
    }
  }
  exit;
}

my $lock = undef;

# all subdirs need to be known before helper commands
guess_maindir();
my $oldwd = chdir_to_maindir();
my $autoreadonly = ( !$reindex && $cmd =~ /^(traceback|vars|succeed|fail|status)$/ );
$autoreadonly = 1 if defined $ENV{"EMAN_READONLY"};
  # don't warn if readonly mode came from env.vars

my @subdirs;
if (-e $subdirs_file) {
  my $subdirs_hdl = my_open($subdirs_file);
  while (<$subdirs_hdl>) {
    chomp;
    push @subdirs, $_;
  }
  close $subdirs_hdl;
} else {
  # the first time we run
  push @subdirs, $maindir;
  # create the file
  if (! $readonly && ! $autoreadonly) {
    my $subdirs_hdl = my_save($subdirs_file);
    print $subdirs_hdl "$maindir\n";
    close $subdirs_hdl;
  }
}
chdir($oldwd) or die "Failed to chdir back to $oldwd";


# Interpret various cmdline options
my %avoid = map { (guess_step($_),1) } @$avoid if defined $avoid;
my %reuse = map { (guess_step($_),1) } @$reuse if defined $reuse;
my %ignore = map { ($_,1) } @$ignore if defined $ignore;
my %avoid_more = map { ($_,1) } @$avoid_more if defined $avoid_more;


## Helper commands for bash scripting of seeds
## These commands do not need index at all, they do not even read it

if ($cmd eq "bash-loadvars") {
  my $varsstr = try_load("eman.vars");
  mydie "eman.vars not set; Did you use 'eman defvar ...' before?"
    if !defined $varsstr;
  print $varsstr."\n";
  exit 0;
}

if ($cmd eq "add-deps") {
  my $step = shift;
  mydie "usage: eman add-deps SPEC DEP1 DEP2 ..." if ! defined $step;
  my $s = guess_step($step); # guess the exact step
  my $olddeps = load_depsarr($s);
  my %deps = map { ($_, 1 ) } @$olddeps; # convert to hash
  foreach my $dep (@ARGV) {
    my $d = guess_step($dep);
    $deps{$d} = 1; # add this among the deps
  }
  chdir_to_stepdir($s);
  save("eman.deps", join("\n", sort {$a cmp $b} keys %deps));
  exit $waserror;
}

if ($cmd eq "defvar") {
  # assuming a sequence of defvar commands
  # construct the file eman.vars
  my $step = guess_step("."); # guess our step name
  my $vars; # ->{varname}->{'opt'}->{'help'} = ...
            # ->{varname}->{'val'} = ...the value from the environment...
            # ->{varname}->{'defined'} = 1  ... always
  my %deps = (); # the dependencies we've learned about

  # load previous eman.deps
  my $olddeps = load_depsarr($step);
  %deps = map { ($_, 1 ) } @$olddeps; # convert to hash

  my @cmds = @ARGV;
  my @var_decls;
  unshift @cmds, "defvar";
  while (scalar @cmds) {
    my $cmd = shift @cmds;
    die "Expected only 'defvar' commands, got: $cmd" if $cmd ne "defvar";
    my $varname = shift @cmds;
    push @var_decls, $varname;
    $vars->{$varname}->{'defined'} = 1;
    $vars->{$varname}->{'val'} = $ENV{$varname};
    # load all flags like 'help', 'default', ...
    while (scalar @cmds && $cmds[0] ne "defvar") {
      my $opt = shift @cmds;
      my ($optname, $optval) = split /=/, $opt, 2;
      $vars->{$varname}->{'opt'}->{$optname} = $optval;
    }
  }
  # check all the vars and prepare the eman.vars file
  my $varshelp = "The step needs the following variables:\n";
    # the info to show upon error
  my $outvars = load_vars_hash($step);
  foreach my $varname (@var_decls) {
    my $thisvarhelp = $vars->{$varname}->{'opt'}->{'help'};
    $thisvarhelp = "" if !defined $thisvarhelp;
    my $thisvardefault = $vars->{$varname}->{'opt'}->{'default'};
    my $usevalue;
    if (defined $vars->{$varname}->{'val'}) {
      # user specified the value
      $usevalue = $vars->{$varname}->{'val'};
    } elsif (defined $vars->{$varname}->{'opt'}->{'inherit'}) {
      # value can be inherited from a particular step
      my $stepvar = $vars->{$varname}->{'opt'}->{'inherit'};
      my ($stepname, $fromvar) = split ':', $stepvar;
      if (!defined $vars->{$stepname}->{'opt'}->{'type'}
          || ($vars->{$stepname}->{'opt'}->{'type'} ne 'reqstep'
          && $vars->{$stepname}->{'opt'}->{'type'} ne 'optstep')) {
        $varshelp .= "    !!! $stepname is not a step\n";
        $waserror = 1;
      }
      $fromvar = $varname if ! defined $fromvar;
      if (defined $outvars->{$stepname}) {
        # the error message when undefined not necessary, the
        # outvar->{stepname} will complain anyway
        my $parent_vars_str = load_vars_str($outvars->{$stepname});
        if (defined $parent_vars_str) {
          my ($var) = grep { $_ =~ m/^$fromvar=/ }
                      split(/\n/, $parent_vars_str);
          if (defined $var) {
            $usevalue = (split('=', $var, 2))[1];
            $usevalue = var_bash_unescape($usevalue);
          }
        }
      }
    } elsif (defined $vars->{$varname}->{'opt'}->{'same_as'}) {
      my $same_as = $vars->{$varname}->{'opt'}->{'same_as'};
      $usevalue = $outvars->{$same_as};
    }

    # try default value for the variable
    $usevalue = $thisvardefault if ! defined $usevalue;

    $varshelp .= "  $varname ... $thisvarhelp"
      .(defined $vars->{$varname}->{'opt'}->{'inherit'}
          ? " [inherited from $vars->{$varname}->{opt}->{inherit}]" : "")
      .(defined $thisvardefault ? " [$thisvardefault]" : "")
      ."\n";
    if (defined $usevalue) {
      # ok, we got the value
      $outvars->{$varname} = $usevalue;
      my $type = $vars->{$varname}->{'opt'}->{'type'};
      if (defined $type) {
        # do some consistency checks and other bits
        if ($type eq "reqstep"
            || ($type eq "optstep" && $usevalue)) {
          $deps{$usevalue} = 1;
          if (!step_valid($usevalue)) {
            $varshelp .= "    !!! $usevalue is not a valid step\n";
            $waserror = 1;
          }
        }
      }
    } else {
      # value missed
      $varshelp .= "    !!! $varname was not defined.\n";
      $waserror = 1;
    }
  }
  if ($waserror) {
    print STDERR $varshelp;
  } else {
    # if eman.vars already exist, load them (but overrite them with the current ones)
    save_vars_hash($step, $outvars);
    save("eman.deps", join("\n", sort {$a cmp $b} keys %deps));
  }
  exit $waserror;
}
## End of commands that don't need index at all.


## Decide if we will lock the index
$oldwd = chdir_to_maindir();
  # for "tb | clone"
if ($readonly || $autoreadonly
    || (-e $indexfile && ! -w $indexfile) || ! -w '.') {
  $readonly = 1;
  print STDERR "Read-only mode.\n" if !$autoreadonly;
} else {
  # obtain lock for index file, keep it locked until we know
  # the command is read-only
# We are not locking any more, we will simply create the index somewhere else
# and move it to its place atomically.
#  $lock = File::NFSLock->new($indexfile, LOCK_EX, 10, 30*60);
#  die "Failed to obtain lock for $indexfile, try --read-only."
#    if !defined $lock;
}

# Load and update index, possibly also saving it
my $idx;
if (($cmd eq "reindex" || $reindex) && $hard_reindex) {
  # do not load any saved values
} else {
  $idx = loadidx();
}
# routines for autotags
my $autotag_rules = undef; # to be loaded by load_autotag_rules("eman.autotags");
# autotag_rules->{steptype} = [ [list of regexes producing one tag],
#   [list of regexes producing another tag] ]

if (! defined $idx || $cmd eq $reindex || $reindex) {
  print STDERR "Updating index\n" if $debug;
  foreach my $subdir (@subdirs) {
    print STDERR "Warning: remote playground '$subdir' does not exist.\n"
      if ! -e $subdir;
    my @steps = glob("$subdir/$dirprefix*.[0-9]*");
    foreach my $s (@steps) {
      print STDERR "indexing $s\n" if $debug;
      next if defined $idx->{basename($s)."path"}; # && defined $idx->{$s."jid"};
      # now avoiding costly regeneration of metadata
      # use --reindex if you miss jobids
      next if ! stepdir_valid($s);
      add_stepdir_to_index($s);

      my $stepname = basename($s);

      # mark that this step uses its deps
      load_list_into_index($stepname, 'USED_BY', 'eman.deps');
      load_list_into_index($stepname, 'DERIVATIVES', 'eman.derivatives');
      load_list_into_index($stepname, 'DERIVED_FROM', 'eman.derived_from');
      print STDERR "$stepname: $idx->{$stepname}\n" if $debug;
    }
  }
}

sub load_list_into_index {
  my $stepname = shift;
  my $index_field = shift;
  my $filename = shift;

  # collect sources of this step
  my $items = load_arr($stepname, $filename);
  if (defined $items) {
    foreach my $d (@$items) {
      $idx->{$index_field}->{$d}->{$stepname} = 1;
    }
  }
}

if ($cmd eq "retag" || $cmd eq "reindex") {
  # reindex implies also refreshing autotags
  if (-e "eman.autotags") {
    $autotag_rules = load_autotag_rules("eman.autotags");
  }
  reindex_tags();
  exit 1 if $waserror;
}

#print STDERR "done here\n";

saveidx($idx) if ! $readonly;
chdir($oldwd) or die "Failed to chdir back to $oldwd";
## End of updating the index

exit 0 if $cmd eq "reindex"; # the job has been done already
exit 0 if $cmd eq "retag"; # the job has been done already


## handle all the various commands

# the following commands are read-only, that is they do not need to write index
if ($cmd eq "guess") {
  # just guessing step directories
  $lock->unlock() if defined $lock;
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    print $step."\n";
  }
  exit 0;
}

if ($cmd eq "qstat") {
  # SGE qstat with guessed step names
  $lock->unlock() if defined $lock;
  qstat();
  exit 0;
}

if ($cmd eq "tabulate") {
  # beautifying all collected results
  $lock->unlock() if defined $lock;
  $waserror = !tabulate();
  exit $waserror;
}

if ($cmd eq "collect") {
  # collecting results from all experiments
  $lock->unlock() if defined $lock;
  $waserror = !collect();
  exit $waserror;
}

if ($cmd eq "list") {
  # listing steps of the given types
  $lock->unlock() if defined $lock;
  $waserror = !list([@ARGV]);
  exit $waserror;
}

if ($cmd eq "status") {
  # listing steps of the given types including status
  $lock->unlock() if defined $lock;
  $show_status = 1;
  $waserror = !list([@ARGV]);
  exit $waserror;
}

if ($cmd eq "tag") {
  # listing steps of the given types including tag
  $lock->unlock() if defined $lock;
  $show_tag = 1;
  $waserror = !list([@ARGV]);
  exit $waserror;
}

if ($cmd eq "annotate") {
  # replacing s.stepname.hash.date (.*) with the required details
  # useful for updating notes
  $lock->unlock() if defined $lock;
  $show_status = 1;
  $waserror = !annotate();
  exit $waserror;
}

if ($cmd eq "vars") {
  # listing steps of the given types including variables
  $lock->unlock() if defined $lock;
  $show_vars = 1;
  if(defined $subst && scalar (@$subst) > 0) {
    # actually use traceback if we are doing substitutions
    $recurse = 0;
    $cmd = "traceback";
  } else {
    $waserror = !list([@ARGV]);
    exit $waserror;
  }
}

if ($cmd eq "deps") {
  $lock->unlock() if defined $lock;
  for my $spec (@ARGV) {
    my $step = guess_step($spec);
    my @deps = split "\n",
      try_load(absolutize_within_stepdir($step, "eman.deps"));
    for my $dep (@deps) {
      print_short($dep);
    }
  }
}

if ($cmd eq "duplicates") {
  # listing steps with identical variables
  $lock->unlock() if defined $lock;
  $waserror = !list_duplicates();
  exit $waserror;
}

if ($cmd eq "traceback") {
  $lock->unlock() if defined $lock;
  mydie "usage: eman traceback SPEC ..." if 0 == scalar @ARGV;
  $show_vars = 1 if defined $subst && scalar (@$subst) > 0;
    # so that there is something to substitute
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    traceback("", $step);
  }
  exit 0;
}

if ($cmd eq "users") {
  $lock->unlock() if defined $lock;
  mydie "usage: eman users SPEC ..." if 0 == scalar @ARGV;
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    my $users = $idx->{'USED_BY'}->{$step};
    next if !defined $users;
    foreach my $u (keys %$users) {
      print_short($u);
    }
  }
  exit 0;
}

if ($cmd eq "tracederivatives") {
  $lock->unlock() if defined $lock;
  mydie "usage: eman derivatives SPEC ..." if 0 == scalar @ARGV;
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    traceindex("", $step, 'DERIVED_FROM');
  }
  exit 0;
}

if ($cmd eq "traceorigin") {
  $lock->unlock() if defined $lock;
  mydie "usage: eman traceorigin SPEC ..." if 0 == scalar @ARGV;
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    traceindex("", $step, 'DERIVATIVES');
  }
  exit 0;
}

if ($cmd eq "traceforward") {
  $lock->unlock() if defined $lock;
  mydie "usage: eman traceforward SPEC ..." if 0 == scalar @ARGV;
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    traceindex("", $step, 'USED_BY');
  }
  exit 0;
}

if ($cmd eq "make-backlinks") {
  $lock->unlock() if defined $lock;
  mydie "usage: eman make-backlinks SPEC ..." if 0 == scalar @ARGV;
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    mk_backlinks($step);
  }
  exit 0;
}

if ($cmd eq "wait") {
  $lock->unlock() if defined $lock;
  mydie "usage: eman wait SPEC ..." if 0 == scalar @ARGV;
  $waserror = do_wait(\@ARGV);
  exit $waserror;
}

if ($cmd eq "select") {
  $waserror = ! select_steps(@ARGV);
  exit $waserror;
}

if ($cmd eq "path") {
  my $stepname = $ARGV[0];
  guess_maindir();
  if (0 == scalar @ARGV) {
    # print path of the playground
    print "$maindir\n";
  } else {
    # print paths of all steps given
    foreach my $key (@ARGV) {
      my $step = guess_step($key);
      print get_stepdir($step), "\n" if defined $step;
    }
  }
  exit $waserror;
}

if ($cmd eq "get-var") {
  my ($stepname, $varname) = @ARGV;
  mydie "Usage: eman get-var STEP VAR" if ! defined $varname;
  my @vars = grep { $_ =~ m/^$varname=/ }
             split /\n/, load_vars_str($stepname);
  if (!defined $vars[0]) {
    print "\n";
  } else {
    my $value = (split '=', $vars[0])[1];
    $value = "" if !defined $value;
    print var_bash_unescape($value), "\n";
  }
  exit $waserror;
}

if ($command eq "fail") {
  mydie "usage: eman fail SPEC ..." if 0 == scalar @ARGV;
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    chdir_to_stepdir($step);
    save("eman.status", "FAILED");
    chdir_to_maindir();
  }
  exit $waserror;
}

if ($command eq "succeed") {
  mydie "usage: eman succeed SPEC ..." if 0 == scalar @ARGV;
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    chdir_to_stepdir($step);
    save("eman.status", "DONE");
    chdir_to_maindir();
  }
  exit $waserror;
}

if ($command eq "outdate") {
  mydie "usage: eman outdate SPEC ..." if 0 == scalar @ARGV;
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    do_outdate($step);
  }
  exit $waserror;
}



if ($cmd eq "abolish") {
  mydie "usage: eman abolish STEPDIR ..." if 0 == scalar @ARGV;
  foreach my $step (@ARGV) {
    my $s = canon_stepdir($step);
      # abolish is pickier wrt to input, so no guessing
    chdir_to_stepdir($s);
    for my $f (glob("*")) {
      next if $f =~ /^eman\./;
      next if $f =~ /^log\./;
      if (-d $f) {
        rmtree($f) or $waserror = 1;
      } else {
        unlink($f) or $waserror = 1;
      }
    }
    save("eman.abolished", `date`);
    rename("eman.status", "eman.status-before-abolish");
    save("eman.status", "ABOLISHED");
    chdir_to_maindir();
  }
  exit $waserror;
}

if ($cmd eq "prepare") {
  my $step = shift;
  mydie "usage: eman prepare STEPDIR" if ! defined $step;
  my $s = guess_step($step); # happily guess the exact step
  $waserror = ! prepare($s);
  exit $waserror;
}

if ($cmd eq "run") {
  my $step = shift;
  mydie "usage: eman run STEPDIR" if ! defined $step;
  my $s = guess_step($step); # happily guess the exact step
  $waserror = ! submit($s);
  exit $waserror;
}

if ($cmd eq "continue") {
  my $step = shift;
  mydie "usage: eman continue STEPDIR" if ! defined $step;
  my $s = guess_step($step); # happily guess the exact step
  chdir_to_stepdir($s);
  my $stat = load_status($s);
  mydie "Only FAILED steps can be continued (after your manual fixes of eman.command)."
    if $stat ne "FAILED";
  save("eman.status", "PREPARED"); # fake our status
  $waserror = ! submit($s);
  exit $waserror;
}

if ($cmd eq "clean") {
  my $step = shift;
  mydie "usage: eman run STEPDIR" if ! defined $step;
  my $s = guess_step($step); # happily guess the exact step
  chdir_to_stepdir($s);
  # Avoid destroying contents of RUNNING and DONE steps!
  my $stat = load_status($s);
  mydie "Only FAILED steps can be cleaned."
    if $stat ne "FAILED";
  # Keep files named eman* and log*. Erase everything else to pave way for eman continue if re-running of eman.command would not be safe otherwise.
  opendir(DIR, '.') or die("Cannot read folder contents");
  my @files = readdir(DIR);
  closedir(DIR);
  foreach my $file (@files)
  {
    next if($file =~ m/^(\.|eman|log)/);
    #print STDERR ("Removing $s/$file...\n");
    safesystem("rm -rf $file") or die("Cannot remove $s/$file: $!");
  }
  # Note that we may have removed files that are created between the INITED and PREPARED states.
  # So we should revert the step state to INITED.
  # It also means that we will have to re-run it using 'eman start', not 'eman continue'.
  safesystem("echo INITED > eman.status") or die("Cannot change status to INITED");
}

if ($cmd eq "start") {
  my $step = shift;
  mydie "usage: eman run STEPDIR" if ! defined $step;
  my $s = guess_step($step); # happily guess the exact step
  $waserror = ! do_start($s);
  exit $waserror;
}


# the following commands don't work with readonly
print STDERR "Warning: running '$cmd' in read-only mode, make sure to reindex.\n"
  if $readonly;

if ($cmd eq "add-tag") {
  mydie "usage: eman add-tag TAG [SPEC ...]" if 0 == scalar @ARGV;
  my $newtag = shift;
  push @ARGV, "." if 0 == scalar @ARGV; # operate on cwd if nothing given
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    my $oldwd = chdir_to_stepdir($step);
    my $oldtag = load_tag($step);
    # eman add-tag is often called from seeds regardless of whether we are running 'init' or 'prepare'
    # That would result in adding the same tag twice, which is meaningless and confusing.
    # So check first whether the new tag is really new.
    my $tag;
    if(defined($oldtag)) {
      my @oldtags = split(/\s+/, $oldtag);
      push(@oldtags, $newtag) unless(grep {$_ eq $newtag} (@oldtags));
      $tag = join(' ', @oldtags);
    }
    else {
      $tag = $newtag;
    }
    save("eman.tag", $tag);
    chdir($oldwd) or die "Failed to chdir back to $oldwd";
  }
  if (!$readonly) {
    chdir_to_maindir();
    reindex_tags();
    saveidx($idx);
  }
  exit $waserror;
}


if ($cmd eq "init") {
  my $steptype = shift;
  mydie "usage: eman init STEPTYPE" if ! defined $steptype;
  my $s = init($steptype);
  $waserror = ! defined $s;
  $waserror = ! do_start($s) if defined $s && $do_start && !$dryrun;
  print $s, "\n" if $print_created_step && defined $s;
  exit $waserror;
}

if ($cmd eq "clone") {
  my $step = shift;
  if (defined $step) {
    # clone the single dir
    my $srcstep = guess_step($step); # happily guess the exact step
    my $srcvarsstr = load_vars_str($srcstep);
    # decide which vars should be cloned
    # for vars that are already defined in the environment, use the value
    # from the environment, not the scenario
    my @srcvars = split /\n/, $srcvarsstr;
    my @usevars = map { my ($varname, $val) = split /=/, $_, 2;
                        defined $ENV{$varname}
                          ? "$varname=".var_bash_escape($ENV{$varname})
			     # prefer environment, remember to escape it
                          : $_; # use the value from the scenario
                      } @srcvars;
    my $news = init(get_steptype($srcstep), \@usevars, $srcstep);
    $waserror = 1 if ! defined $news;
    $waserror = ! do_start($news) if defined $news && $do_start && !$dryrun;
    print $news, "\n" if $print_created_step && defined $news;
    if ($do_outdate) {
      if ($waserror) {
        print STDERR "Not outdating $srcstep, there was an error.\n";
      } else {
        do_outdate($srcstep);
      }
    }
  } else {
    print STDERR "Loading recipe from stdin.\n";
    my $recipestr = load("-");
    my $recipe = parse_recipe([split /\n/, $recipestr]);
    print Dump($recipe) if $debug;
    my $depmap = {};
    my $newtopstep = init_by_recipe($recipe, $depmap);
    $waserror = ! do_start($newtopstep)
      if defined $newtopstep && $do_start && !$dryrun;
    if (defined $newtopstep) {
      if ($print_created_step) {
        # we don't print the traceback if we are printing top step name
        # the traceback would mess stdout
        print $newtopstep, "\n";
      } else {
        $show_status = 1;
        traceback("NEW ", $newtopstep);
        print "Root: ", $newtopstep, "\n";
        print STDERR "Traceback of NEW not reliable in --dry-run.\n" if $dryrun;
      }
    }
  }
  exit $waserror;
}

if ($command eq "redo") {
  my $step = shift;
  mydie "usage: eman redo STEPDIR" if ! defined $step;
  my $s = guess_step($step); # happily guess the exact step
  $avoid{$s} = 1; # assume the main experiment is to be redone anyway
  my $recipe = traceback_to_recipe($s);
  my $depmap = {};
  my $newtopstep = init_by_recipe($recipe, $depmap);
  $waserror = ! do_start($newtopstep)
    if defined $newtopstep && $do_start && !$dryrun;
  if (defined $newtopstep) {
    if ($print_created_step) {
      # we don't print the traceback if we are printing top step name
      # the traceback would mess stdout
      print $newtopstep, "\n";
    } else {
      $show_status = 1;
      traceback("OLD ", $s);
      traceback("NEW ", $newtopstep);
      print "Root: ", $newtopstep, "\n";
      print STDERR "Traceback of NEW not reliable in --dry-run.\n" if $dryrun;
    }
  } else {
    $waserror = 1;
  }
  if ($do_outdate) {
    if ($waserror) {
      print STDERR "Not outdating $s, there was an error.\n";
    } else {
      do_outdate($s);
    }
  }
  exit $waserror;
}


if ($cmd eq "add-dir") {
  $waserror = ! add_dir(@ARGV);
  exit $waserror;
}

if ($cmd eq "add-remote") {
  $waserror = ! add_remote_playground(@ARGV);
  exit $waserror;
}

$lock->unlock() if defined $lock;
exit $waserror;
## end of main

sub collect {
  # collect results from all experiments
  my $resconf = load($resultsconffile);
  my $outh = my_save($resultsfile);
  my $ok = 1;
  my $got;
  my %knowntag; # a local cache of tags
  foreach my $line (split /\n/, $resconf) {
    my ($name, $glob, $regexorcmd) = map { s/^ +//; s/ +$//; $_ }
                                     split /\t/, $line;
    my @files = ( map { glob("$_/$glob") } @subdirs);
    # print STDERR "$name ($glob): $regexorcmd\n";
    # print STDERR join("\n", @files);
    # print STDERR "\n\n";
    foreach my $f (@files) {
      my $step = guess_stepname_from_pathname($f); #$f; $step =~ s/\/.*//;
      if (!defined $step) {
        print STDERR "Warning: Tried to collect from a directory that is not a step? Dirname: $f\n";
	next;
      }
      my $name_to_res = undef;
      my $cmd = undef;
      if ($regexorcmd =~ /^CMD:(.*)\$\$(.*)/) {
        # e.g. "CMD: du -sh $$"
	$cmd = "$1 $f $2";
      } elsif ($regexorcmd =~ /^CMD: *(.*)/) {
	$cmd = "cat $f | $1";
      }
      if (defined $cmd) {
        # run the given command
	# print STDERR "Running: $cmd\n";
        my $res = `$cmd`;
        $res = Encode::decode_utf8($res); # assume the command returns utf8
	# print STDERR "GOT: $res\n";
        chomp $res;
        if ($name eq "*") {
          # assume the command emits name\tvalue pairs
          foreach my $pair (split /\n/, $res) {
            my ($k, $val) = split /\t/, $pair;
            $name_to_res->{$k} = $val;
          }
        } else {
          # whole output is the value
          $res =~ s/\n+/ /;
          $name_to_res->{$name} = $res;
        }
      } else {
        # no command, load the given file
        my $cont = load($f);
        if ($cont =~ /$regexorcmd/) {
          $name_to_res->{$name} = $1;
        } else {
          print STDERR "$f:Missed result for $name, no match of /$regexorcmd/\n";
          $ok = 0;
          next;
        }
      }
      # emit all obtained scores
      foreach my $k (keys %$name_to_res) {
        my $res = $name_to_res->{$k};
        $res = '' if(!defined($res));
        if (defined $got->{$step}->{$k} && $got->{$step}->{$k} ne $res) {
          print STDERR "$f:Conflicting result for $k:"
            ." $res vs. previous $got->{$step}->{$k}\n";
          $ok = 0;
        } else {
          $got->{$step}->{$k} = $res;
        }
        my $tag = $knowntag{$step};
        if (!defined $knowntag{$step}) {
          $tag = compiled_tag_string($step);
        }
        $knowntag{$step} = $tag;
        print $outh $step, "\t", load_status($step), "\t",
	  $k, "\t", $res, "\t", $tag, "\n";
      }
    }
  }
  foreach my $step (keys %knowntag) {
    # emit also all tags
    print $outh $step, "\t", load_status($step), "\t",
      "TAG", "\t", $knowntag{$step}, "\n";
  }
  close $outh;
  return $ok;
}

sub parse_recipe {
  # parse traceback output with vars into a recipe
  my $lines = shift;
    # input stream of lines
  my $cutprefix = shift;
    # the depth we need to cut now
  my $recipe = shift;
    # the recipe so far

  $cutprefix = "" if ! defined $cutprefix;

  # peek at the first line, if going deeper, add one more dep,
  # if going shallower or end, return accumulator
  my $exact = "$cutprefix+- ";
  my $deeper = "$cutprefix|  +- ";
  my $shallower = substr($cutprefix, 0, -3);
  while (defined $lines && defined $lines->[0]) {
    if ($lines->[0] =~ /^\Q$exact\E([^ ]+)$/) {
      if (defined $recipe->{"name"}) {
        # this is actually one more dependency of our father, ie. our brother,
        # not us. Return and have the father start the brother
        last;
      }
      my $name = $1;
      print STDERR "$cutprefix:Exact at: $lines->[0]\n" if $debug;
      $recipe->{"name"} = $name;
      $recipe->{"vars"} = [];
      $recipe->{"deps"} = [];
      shift @$lines;
      my $tailexact = "$cutprefix|  | ";
      while (defined $lines->[0] && $lines->[0] =~ /^\Q$tailexact\E(.*)/) {
        my $line = $1;
        my $thisline = shift @$lines;
        next if $line =~ /^Job:/; # skip tag, jobid and other things
        if ($line =~ /^[A-Za-z_0-9]+=/) {
          # let's hope this is a variable
          push @{$recipe->{"vars"}}, $line;
        print STDERR "$cutprefix:    got var: $line\n" if $debug;
        } else {
	  if ($thisline eq $tailexact) {
	    next; # skipping blank line, probably introduced by deliberate
	          #removal of a variable, -s /...//
          } else {
            mydie "Bad recipe, strange line: $thisline";
	  }
        }
      }
      next; # now read deps etc
      # return parse_recipe($lines, $cutprefix, $recipe);
    }

    if (defined $lines && defined $lines->[0]
        && $lines->[0] =~ /^\Q$deeper/) {
      # Delving deeper by one level
      print STDERR "$cutprefix:Deeper at: $lines->[0]\n" if $debug;
      my $dep = parse_recipe($lines, $cutprefix."|  ");
      push @{$recipe->{"deps"}}, $dep;
      print STDERR "$cutprefix:New dep for $recipe->{name}: $dep->{name}\n" if $debug;
      print STDERR "$cutprefix:Deeper tail at: ".($lines->[0]||"EOF")."\n" if $debug;
      next; # read further deps
      # return parse_recipe($lines, $cutprefix, $recipe);
    }

    if (! defined $lines->[0]
      || $lines->[0] =~ /^(\|  )*\+- /) {
      # Going shallower
      print STDERR "$cutprefix:Return from $recipe->{name} at: ".($lines->[0]||"EOF")."\n" if $debug;
      last;
    }

    mydie "Bad recipe, unexpected line: $lines->[0]";
  }
  return $recipe;
}

sub update_step_names_in_varsarr {
  my $depmap = shift;
  my $oldvars = shift;

  # print "REPL: ".join(" ", %$depmap)."\n" if defined $depmap;
  # print "VARSBEF: @$oldvars\n";
  my @newvars = map {
      foreach my $oldd (keys %$depmap) {
        my $newd = $depmap->{$oldd};
        #print "VARSOLDD $oldd\n";
        #print "VARSNEWD $newd\n";
        s/\Q$oldd\E/$newd/g;
      }
      $_;
    } ( @$oldvars );
  # print "VARSAFT: @newvars\n";
  return \@newvars;
}

sub init_by_recipe {
  # given a recipe; a recipe has the following form:
  #      $recipe = { "name"=>'s.type.abcdef.2010',
  #                  "vars"=>['X=x', 'Y=y'], "deps"=>[recipe1, recipe2]}
  # initializes a fresh tree using the variables and dependences
  # we attempt to reuse existing steps unless they failed or are '--avoid'ed
  my $recipe = shift;
  my $depmap = shift;
  confess "implementation error: undef depmap" if !defined $depmap;

  my $thisname = $recipe->{"name"};
  my $thissteptype = get_steptype($thisname);

  if ($reuse{$thisname}) {
    print STDERR "Forced to --reuse: $thisname\n";
    return $thisname;
  }
  if ($ignore{$thisname} || $ignore{$thissteptype}) {
    print STDERR "Ignoring (kind of reusing): $thisname\n";
    return $thisname;
  }

  # print "INIT_BY_RECIPE: $thisname\n";

  # handle all dependencies
  my $olddeps = $recipe->{"deps"};
  my @newdeps = ();
  if (defined $olddeps && scalar @$olddeps > 0) {
    foreach my $d (@$olddeps) {
      # print "DEPMAP1: ".join(" ", %$depmap)."\n" if defined $depmap;
      my $newd = init_by_recipe($d, $depmap);
      return undef if !defined $newd;
      push @newdeps, $newd;
      my $oldd = $d->{"name"};
      # print "OLDD $oldd\n";
      # print "NEWD $newd\n";
      if ($newd ne $oldd) {
        $depmap->{$oldd} = $newd;
      }
      # print "DEPMAP2: ".join(" ", %$depmap)."\n" if defined $depmap;
    }
  }

  # perform replacements of deps in vars
  # note that previous init_by_recipe might have proposed more replacements
  my $oldvars = $recipe->{"vars"};
  my $newvars = update_step_names_in_varsarr($depmap, $oldvars);
  # env. vars override the recipe (for usecases like V=x eman redo)
  my @newvars = map { my ($varname, $val) = split /=/, $_, 2;
                   defined $ENV{$varname}
                     ? "$varname=".var_bash_escape($ENV{$varname})
                 # prefer environment
                     : $_; # use the value from the scenario
                 } @$newvars;

  # check if such a step exists already
  my $knownstep;
  my $hash = get_hash_from_vars_deps($thisname, \@newvars, \@newdeps);
  if ($debug) {
    print STDERR "CHECKING $hash:\n";
    print STDERR join("\n", @newvars)."\n";
    print STDERR join("\n", @newdeps)."\n";
  }
  # find suitable known step
  $avoid{$thisname}=1 if $avoid_all;
    # --all-avoid forbids reusing *input* steps
    # but it does not prohibit reusing freshly created steps
  if (defined $idx->{$thisname} && $idx->{$thisname} eq $hash
      && step_good_to_reuse($thisname)
      && !$avoid{$thisname}
      && !$avoid_more{$thisname}
      && !$avoid_more{$thissteptype}
      ) {
    print STDERR "The given $thisname actually fits.\n" if $debug;
    $knownstep = $thisname;
  } else {
    $knownstep = find_usable_step_given_hash($hash);
  }

  if (defined $knownstep) {
    print STDERR "Reusing existing step: $knownstep\n";
    # print "LEAVING INIT_BY_RECIPE: $thisname\n";
    return $knownstep;
  } else {
    # init a new step using the vars
    print STDERR "Initing new step $thissteptype (for $thisname in the recipe).\n";
    my $newstep = init($thissteptype, \@newvars, $thisname);
    return undef if ! defined $newstep;
    # Double check that initing the new step did not lead to exacty the known
    # step. This can happen due to default or blank variable values -- they are
    # not mentioned in the traceback (so we don't find the known step in the
    # first place).
    my $oldknownstep = find_usable_step_given_hash($idx->{$newstep});
    if (defined $oldknownstep && $oldknownstep ne $newstep) {
      print STDERR "The new $newstep is identical to $oldknownstep. Removing the new $newstep.\n";
      rmtree($newstep) or die "Warning: failed to remove $newstep.";
      remove_step_from_index($newstep);
      $newstep = $oldknownstep;
    }

    # print "LEAVING INIT_BY_RECIPE: $thisname\n";

    if ($do_outdate && !$dryrun) {
      my $oldpath = get_stepdir($thisname);
      if (-e $oldpath) {
        do_outdate($thisname);
	# consider outdating only local steps unless --remote
      }
    }

    return $newstep;
  }
}

sub find_usable_step_given_hash {
  my $hash = shift;

  my $knownstep = undef; # output placeholder
  my $knownsteps = $idx->{$hash};
  my $knownstep_ctime;
  if (defined $knownsteps) {
    my @usable = ();
    foreach my $k (@$knownsteps) {
      print STDERR "Considering old: $k\n" if $debug;
      next if $avoid{$k};
      next if $avoid_more{$k};
      next if $avoid_more{get_steptype($k)};
        # an explicit wish to ignore this step
      if ($reuse{$k}) {
        # an explicit wish to use this step, ignore all other options
        print STDERR "Forced to reuse $k\n" if $verbose;
        @usable = ($k);
        $knownstep = $k;
        last;
      }
      if (step_good_to_reuse($k)) {
        push @usable, $k;
        my $this_ctime = -C $k;
        # of all the usable, select the oldest
        if (!defined $knownstep || $knownstep_ctime < $this_ctime) {
          $knownstep_ctime = $this_ctime;
          $knownstep = $k;
        }
      } else {
        print STDERR "Ignoring unusable $k\n" if $verbose;
      }
    }

    if (1<scalar(@usable)) {
      print STDERR "Selecting $knownstep of all the usable: @usable\n"
        if $verbose;
    }
  }
  return $knownstep;
}

sub step_good_to_reuse {
  my $step = shift;
  my $stepdir = get_stepdir($step);
  return (defined $stepdir && -d $stepdir
    && step_valid($step)
    && load_status($step) !~ /FAILED|NONEXISTENT|OUTDATED|ABOLISHED/
  );
}


my $init_dryrun_no = 0;
sub init {
  my $steptype = shift;
  my $varsarr = shift; # optional array of strings VAR="sd sdf"
                       # to be passed to the seed
  my $derived_from = shift;
  my $seed = $seedsdir."/".$steptype;
  mydie "Seed $seed not found." if ! -e $seed;
  mydie "Bad seed name, '.' not allowed." if $steptype =~ /\./;
  my $timestamp = `date '+%Y%m%d-%H%M'`; chomp $timestamp;
  mydie "Bad timestamp: $timestamp" if $timestamp !~ /^[-0-9]+$/;
  my $s;
  my $stepname;
  if ($dryrun) {
    $init_dryrun_no = 0 if !defined $init_dryrun_no;
    $init_dryrun_no++;
    $stepname = "s.fake.$init_dryrun_no";
    print STDERR "$stepname: ", join(" ", @$varsarr), "\n";
    add_fake_step_to_index($stepname, $varsarr);
    return $stepname;
  }
  add_dir($subdir);
  $s = mkdiruniq(abs_path($subdir)."/".$dirprefix.$steptype.".", ".".$timestamp);
  $stepname = basename($s);
  # if we are given $oldname, the name of the step we are just cloning
  # modify the given vars by replacing oldname with stepname
  $varsarr = update_step_names_in_varsarr(
               { $derived_from => $stepname },
               $varsarr)
             if defined $derived_from;
  # populate the directory with all relevant files
  quietsystem("cp $seed $s/eman.seed") or die;
  my $oldwd = mychdir($s);
  quietsystem("set > eman.init_env") or die;
  save("eman.derived_from", $derived_from) if defined $derived_from;
  my $ok = 1;
  my $preservedir = 0;
  my @varsoverride = ();
  @varsoverride = @$varsarr if defined $varsarr;
  $ok = safesystem("INIT_ONLY=yes @varsoverride EMAN_READONLY=yes ./eman.seed >&2");
  if ($ok) {
    $preservedir = 1;
    print STDERR "Step $stepname inited, checking required files, supplying defaults.\n"
      if $verbose;

    # tag: can be blank, non-blank must be valid
    my $tag = try_load("eman.tag");
    $tag = "" if !defined $tag;
    # merge add_tag values and existing tag values
    my %tags = map { ($_, 1) } grep {/./} (split(/\s+/, $tag), @$add_tag);
    save("eman.tag", join(" ", keys %tags));

    # deps: can be blank, non-blank must be valid
    my $deps = try_load("eman.deps");
    if (defined $deps) {
      foreach my $d (split /\n/, $deps) {
        if (!step_valid($d)) {
          print STDERR "Invalid dependence: $d\n";
          $ok = 0;
        }
      }
    } else {
      save("eman.deps", ""); # save blank dependencies
    }

    # vars: must exist (blank vars make no sense)
    if (! defined try_load("eman.vars")) {
      print STDERR "$seedsdir/$steptype did not create eman.vars for $stepname\n";
      $ok = 0;
    }
  }

  if ($ok) {
    save("eman.status", "INITED");
    mychdir($oldwd);
    add_stepdir_to_index($s); # so that further cloning can use that
    saveidx($idx);
    print STDERR "Inited: $stepname\n";
    if (defined $derived_from) {
      # save also that where we are derived from
      my $derived_from_dir = get_stepdir($derived_from);
      if (defined $derived_from_dir && -w $derived_from_dir) {
        mychdir($derived_from_dir);
        append("eman.derivatives", $stepname);
      } else {
        print STDERR "Not mentioning in $derived_from that we derived $stepname from it.\n";
      }
    }
  } elsif ($preservedir) {
    print STDERR "Failed to init the step. Check and delete: $stepname\n";
    $waserror = 1;
    save("eman.status", "INITFAILED");
  } else {
    print STDERR "Failed to init the step. Removing $stepname\n";
    mychdir($startupwd);
    rmtree($s) or die "Failed to remove $stepname";
  }
  mychdir($oldwd);
  return $ok ? $stepname : undef;
}

sub prepare {
  my $s = shift;
  my $status = load_status($s);
  if ($status =~ /^(PREPARED|DONE)$/
    || $assume_abolished_ok && $status eq "ABOLISHED") {
    print STDERR "$s already prepared.\n";
    return 1;
  }
  mydie "Only inited steps can be prepared: $s is $status"
    if $status ne "INITED" && $status ne "PREPFAILED";

  my $prevdir = chdir_to_stepdir($s);
  my $ok = 1;
  $ok = safesystem("eval \$(cat eman.vars) EMAN_READONLY=yes ./eman.seed >&2");
  print STDERR "Step $s prepared, checking required files.\n" if $verbose;
  if (! -e "eman.command") {
    $ok = 0;
    print STDERR "Step $s prepared badly. No eman.command\n"
  }
  if ($ok) {
    print STDERR "Step $s prepared.\n";
    save("eman.status", "PREPARED");
  } else {
    save("eman.status", "PREPFAILED");
  }
  mychdir($prevdir);
  return $ok;
}

sub do_start {
  # 1. check if all predecessors done, prepared or inited
  #    if *failed, fail
  # 2. walk back, make sure all are prepared (if not, prepare
  #    if failed, fail
  # 3. walk back, if done, ok, if prepared, submit
  #    subshould
  # check predecessors and if none of them failed
  # so that we wait for them
  my $s = shift;

  my $all_ok = fold_back($s,
                 sub {
                   my $this = shift;
                   my $aku = shift;
                   return 0 if !$aku; # propagate failure
                   my $stat = load_status($this);
                   if ($stat =~ /FAILED|OUTDATED/ || $stat eq "NONEXISTENT") {
                     return 0;
                   } else {
                     return 1;
                   }
                 },
                 1, # seed value
               );
  if (!$all_ok) {
    print STDERR "Cannot start $s, some deps have failed:\n";
    brief_traceback("  ", $s);
    return 0;
  }

  # now prepare all that need preparation
  my $prep_ok = fold_back($s,
    sub {
      my $this = shift;
      my $aku = shift;
      return 0 if !$aku; # propagate failure
      my $stat = load_status($this);
      return 1 if $stat =~ /^(PREPARED|DONE|RUNNING|STARTING)$|^WAITING/;
      return 1 if $assume_abolished_ok && $stat eq "ABOLISHED";
      return prepare($this);
    },
    1, # seed value
  );
  if (!$prep_ok) {
    print STDERR "Cannot start $s, failed to prepare some deps:\n";
    brief_traceback("  ", $s);
    return 0;
  }

  # finally submit bits that need to run
  my $start_ok = fold_back($s,
    sub {
      my $this = shift;
      my $aku = shift;
      return 0 if !$aku; # propagate failure
      my $stat = load_status($this);
      return 1 if $stat =~ /^(DONE|RUNNING|STARTING)$|^WAITING/;
      return 1 if $assume_abolished_ok && $stat eq "ABOLISHED";

      # convert each prerequisite name to jobid
      my @holds = ();
      my $deps = load_depsarr($this);
      if (defined $deps) {
        foreach my $dep (@$deps) {
          next if load_status($dep) eq "DONE";
          my $depid = load_jobid($dep);
          die "Failed to get jobid of $dep" if !defined $depid;
          push @holds, $depid;
        }
      }

      return submit($this, \@holds);
    },
    1, # seed value
  );
  if (!$start_ok) {
    print STDERR "Cannot start $s, failed to submit some steps.\n";
    return 0;
  }

  if ($do_wait) {
    return do_wait([$s]);
  }
  return 1;
}

sub do_wait {
  # wait for all given steps
  my $step_specs = shift;
  my $waserror = 0;

  my %steps = map { my $s = guess_step($_); ($s, load_status($s)) }
                @$step_specs;
  # check if any steps have no chance
  my @no_chance = grep { $steps{$_}
                         !~ /^(STARTING|RUNNING|DONE|FAILED|OUTDATED)$/ }
                  keys %steps;
  if (0 < scalar @no_chance) {
    print STDERR "Won't wait for these, not running:\n";
    foreach my $s (@no_chance) {
      print STDERR "  $s\t$steps{$s}\n";
    }
    $waserror = 1;
  }
  my @queue = grep { $steps{$_} =~ /^(STARTING|RUNNING)$/ } keys %steps;
  print STDERR "Waiting for ".scalar(@queue)." jobs.\n";
  while (0 < scalar @queue) {
    sleep $wait_sleep;
    my @newqueue = ();
    foreach my $step (@queue) {
      my $s = load_status($step);
      if ($s !~ /^(STARTING|RUNNING|DONE|FAILED|OUTDATED)$/ ) {
        print STDERR "Got unexpected status: $step\t$s\n";
        $waserror = 1;
        next;
      }
      push @newqueue, $step if $s =~ /^(STARTING|RUNNING)$/;
    }
    @queue = @newqueue;
  }
  return $waserror;
}

sub fold_back {
  my $step = shift;
  my $sub = shift;
  my $aku = shift;

  my $deps = load_depsarr($step);
  foreach my $dep (@$deps) {
    return $aku if $ignore{$step} || $ignore{get_steptype($step)};
      # explicit skipping subtrees of individual steps or steps of a given type
    $aku = fold_back($dep, $sub, $aku);
  }
  return $sub->($step, $aku);
}


sub brief_traceback {
  my $prefix = shift;
  my $s = shift;

  my @mem = ($show_status, $show_vars, $show_log);
  $show_status = 1;
  $show_vars = 0;
  $show_log = 0;
  traceback($prefix, $s);
  ($show_status, $show_vars, $show_log) = @mem;
}


sub submit {
  # assume all predecessors are DONE or their jobids are provided
  # so that we wait for them
  my $s = shift;
  my $holdjids = shift;
  my $status = load_status($s);
  mydie "Only prepared steps can be submitted, $s is $status"
    if $status ne "PREPARED";

  my $prevdir = chdir_to_stepdir($s);
  save("eman.status", "STARTING");
  my $ok = 1;
  my $jid = undef;
  # XXX should split holdjids into holds (for sge) and active waiting loops
  my @sgeholds = ();
  my @plainholds = ();
  foreach my $jid (@$holdjids) {
    if ($jid =~ /^[0-9]+$/) {
      # this is SGE job id
      push @sgeholds, "-hold_jid $jid";
    } else {
      push @plainholds, $jid;
    }
  }

  my $oldsgeholds = $ENV{"HOLDS"};
  $oldsgeholds ||= "";
  my $sgeholdsstr = join(" ", ($oldsgeholds, @sgeholds));

  # just to be sure
  quietsystem("chmod +x eman.command")
    or print STDERR "Failed to ensure executable bit for eman.command in $s\n";

  if (!defined $qsub_available) {
    $qsub_available = `which qsub 2>/dev/null` =~ /\//;
      # check if there is such an executable at all
    if ($qsub_available) {
      # check whether it is SGE qsub or PBS qsub
      my $sgeversion = `qsub -help nonexistent-file 2>&1 | grep GE 2>/dev/null`;
      $qsub_available = 0 if $sgeversion !~ /GE/;
    }
  }
  if ($sge && !$qsub_available) {
    print STDERR "Disabling SGE by default, failed to find qsub.\n";
    $sge = 0;
  }

  if (! $sge) {
    # avoid sun grid engine
    # XXX must wait for running jobs
    my $waitscript = "";
    $waitscript = "$eman --reindex wait @plainholds; "
      if 0 < scalar @plainholds;

    save("eman.wrapcommand", 'echo Host:PID: `hostname`:$$ ; '.$waitscript.'./eman.command 2>&1; echo PID: $$ > eman.wrapcommand.done');
    save("eman.status", "RUNNING"); # set status before starting to avoid race
    $ok = safesystem("( nohup /bin/bash ./eman.wrapcommand > log 2>&1 & )");
    if ($ok) {
      # get process id
      my $now = time();
      while (! defined $jid && time()-$now < 60) {
        if (-e "log") {
          my $hdl = my_open("log");
          my $nl = 0;
          while(<$hdl>) {
            $nl++;
            last if $nl > 10;
            if (/^Host:PID: (.+)$/) {
              $jid = $1;
              last;
            }
          }
          close $hdl;
        }
        sleep 1;
      }
      if (! defined $jid) {
        $ok = 0;
        print STDERR "Failed to get process id from the file log.\n";
      }
    }
  } else {
    # use sge
    die "Unimplemented to wait for some non-sge jobs: @plainholds"
      if 0 < scalar @plainholds;

    my $vars_hash = load_vars_hash($s);
    # include environment vars
    map { $vars_hash->{$_} = $ENV{$_} } grep { $_ =~ m/^EMAN_/ } keys %ENV;

    my @opts = ("-hard");
    push @opts, ("-j", "y");
    push @opts, ("-cwd");
    push @opts, ("-S", "/bin/bash");
    push @opts, ("-p", $priority);
    # interpret SGE options
    my $real_queue = $queue // $vars_hash->{EMAN_QUEUE};
    if (defined $real_queue) {
      push @opts, ("-q", $real_queue);
    }
    my $real_exclude_comp = $exclude_comp // $vars_hash->{EMAN_EXCLUDECOMP};
    if (defined ($real_exclude_comp)) {
      die "Cannot use --queue and --exclude-comp at the same time"
        if defined $real_queue;
      push @opts, ("-q", "*@*&!$real_exclude_comp");
    }
    my $real_time = $time // $vars_hash->{EMAN_TIME};
    if (defined $real_time) {
      push @opts, ('-l', "h_rt=".$real_time);
    }
    my $real_mem = $mem // $vars_hash->{EMAN_MEM} // $qsub_defaults{mem};
    if (defined $real_mem && $real_mem ne "") {
      if ($env eq "rwth") {
        push @opts, ('-l', "h_vmem=".$real_mem);
      } else {
        # UFAL setup
        push @opts, ('-hard', '-l', "mf=".$real_mem);
        push @opts, ('-hard', '-l', "h_vmem=".$real_mem);
      }
    }
    my $real_disk = $disk // $vars_hash->{EMAN_DISK};
    if (defined $real_disk) {
      if ($env eq "rwth") {
        die "Unsupported --disk at rwth.";
      } else {
        # UFAL setup
        push @opts, ('-l', "mnthf=".$real_disk);
      }
    }
    # add all other directives --limit
    push @opts, map {('-l', $_)} @limits;
    # add all job holds
    push @opts, map {('-hold_jid', $_)} @userholds;



    #check for multi-core support
    my $real_cores = $cores // $vars_hash->{EMAN_CORES} // $qsub_defaults{cores};
    if ((defined $real_cores) && ($real_cores!=1)) {
        push @opts, (" -pe smp $real_cores ");
    }

    save("eman.status", "RUNNING"); # set status before starting to avoid race
    # Log the command, too. If we ever need to restart the job we will want to know the original memory+disk requirements.
    # (SGE stores the requirements in the epilog text but the job may die without ever writing the epilog.)
    my $jobname = shorten_name($s);


    my $qsub_command = "qsub -C '' $sgeholdsstr -N $jobname -o log.o\\\$JOB_ID @opts ./eman.command";
    open(LOG, '>log') or die("Cannot write log: $!");
    print LOG ("$qsub_command\n");
    close(LOG);
    $ok = safesystem("( $qsub_command 2>&1 ) >> log");
    if ($ok) {
      # get job id
      my $hdl = my_open("log");
      my $nl = 0;
      while(<$hdl>) {
        $nl++;
        last if $nl > 10;
        if (/Your job ([0-9]+) .*has been submitted/) {
          $jid = $1;
          last;
        }
      }
      close $hdl;
    }
  }

  if (defined $jid) {
    save("eman.jobid", $jid);
  } else {
    die "Failed to get jobid of the just submitted $s";
  }

  if ($ok) {
    print STDERR "Step $s submitted as job $jid\n";
  } else {
    save("eman.status", "FAILED");
  }
  mychdir($prevdir);
  return $ok;
}

sub shorten_name {
  my $s = shift;
  my ($pref, $type, $hash, $time) = split /\./, $s;
  $type = substr($type, - min(length $type, 4)); # last 4 characters
  return "$type.$hash";
}

sub list_duplicates {
  my $waserror = 0;

  my %hashcount; # how many different steps have the same hash
  my %share_hash; # the steps themselves
  foreach my $s (keys %$idx) {
    next if $s !~ /\Q$dirprefix\E([^\.]+)\..*/;
      # this is not a step
    my $hash = $idx->{$s};
    push @{$share_hash{$hash}}, $s;
    $hashcount{$hash} ++;
  }

  foreach my $hash (sort {$hashcount{$a} <=> $hashcount{$b}}
                    grep { $hashcount{$_} > 1 }
                    keys %hashcount) {
    print "\n";
    my $ok = list($share_hash{$hash});
    $waserror = 1 if !$ok;
  }
  return $waserror;
}

sub list {
  my $args = shift;
  # listing steps of the given types
  my $only_some_steptypes = 0;
  my %requested_steptype;
  my %requested_by_spec;
  if (0 < scalar @$args) {
    $only_some_steptypes = 1;
    %requested_steptype = map { ($_, 1) } @$args;
  }
  my %steps_to_list = ();
  foreach my $s (all_steps()) {
    next if ! step_valid($s);
    my $steptype = get_steptype($s);
    next if $only_some_steptypes && !defined $requested_steptype{$steptype};
    # mark that we accepted this argument
    $requested_steptype{$steptype} = 2
      if defined $requested_steptype{$steptype};
    $steps_to_list{$s} = 1;
  }
  my @not_found = ();
  foreach my $req (keys %requested_steptype) {
    if ($requested_steptype{$req} == 1) {
      my $guess = guess_step($req);
      if (defined $guess) {
        # this was not a steptype but a specific experiment
        $steps_to_list{$guess} = 1;
        $requested_by_spec{$guess} = 1;
      } else {
        push @not_found, $req;
      }
    }
  }
  foreach my $s (sort { if (-e $a && -e $b) { -C $b <=> -C $a } else { -1 } }
                 keys %steps_to_list) {
    if ($list_only_steps_with_no_users) {
      my $users = $idx->{'USED_BY'}->{$s};
      next if defined $users;
    }

    # filter out remote steps, unless:
    # 1) --remote was specified, or
    # 2) the user asked for a particular step (e.g. eman stat s.srilm.123)
    #
    # XXX hack: eman select calls list() with fully specified step names,
    # so we filter remote steps even when they are fully specified *if*
    # the command was "eman select"
    if (! $remote && ($cmd eq "select" || ! $requested_by_spec{$s})) {
      # do not list remote steps by default
      my $steppath = $idx->{$s . "path"};
      $steppath =~ s/$s//; # remove step name from path
      next if abs_path($steppath) ne abs_path($maindir);
    }
    print_short($s);
  }
  my $ok = 1;
  foreach my $req (@not_found) {
    $ok = 0;
    print STDERR "No steps of type: $req\n";
  }
  return $ok;
}

sub annotate_replace {
  my $s = shift;
  my $comment = shift;
  return $s.$comment if ! defined $idx->{$s}; # this is not a step
  my @details = short_details($s);
  if (0 == scalar @details) {
    if ($comment eq " ()") {
      return $s;
    } else {
      return $s.$comment;
    }
  } else {
    return $s." (".join(" ", @details).")";
  }
}

sub annotate {
  # no arguments
  while (<>) {
    s/(\Q$dirprefix\E\.*[^\s]*\.\d{8}-\d{4})(( \([^\)]*\))?)/annotate_replace $1,$2/ge;
    print;
  }
  return 1; # there was no error in annotation
}

sub short_details {
  my $s = shift;
  my @out = ();
  push @out, load_status($s) if $show_status;
  push @out, compiled_tag_string($s) if $show_tag;
  push @out, (load_jobid($s) || "") if $show_jobid;
  push @out, show_disk_usage($s) if $show_disk_usage;
  push @out, show_dir($s) if $showdir;
  return @out;
}
sub print_short {
  my $s = shift;

  print $s;
  print "\t", join("\t", short_details($s));
  print "\n";
  print_vars("  ", $s) if $show_vars;
  print_log("  ", $s) if $show_log;
}
sub print_vars {
  my $prefix = shift;
  my $s = shift;
  my $seenseeds = shift;
  my @depsinvars = ();
  my $v = load_vars_str($s);
  return if !defined $v;
  foreach my $l (sort(split /\n/, $v)) {
    # perform substitutions, if defined and step not reused
    if (defined $subst && ! $reuse{$s}) {
      foreach my $s (@$subst) {
	# debugging aid:
        # print "$prefix$l <----- old value\n" if $l =~ /DECO|TGTAUG|LMS/;
        # print "$prefix   =~ s".$s."\n" if $l =~ /DECO|TGTAUG|LMS/;
        eval '$l =~ s'.$s;
      }
    }
    if ($anonymize) {
      my $stepstr = $dirprefix . get_steptype($s) . "." . $seenseeds->{$s};
      $l =~ s/$s/$stepstr/g; # replace occurrences of step name with its canonical identifier
      while ($l =~ m/\Q$dirprefix\E([^\.]*)\.([a-f0-9]{8}\.\d{8}-\d{4})/g) {
        my $steptype = $1;
        my $step = "$dirprefix$1.$2";
        push @depsinvars, $step if ! grep { $_ eq $step } @depsinvars;
        if (! defined $seenseeds->{$step}) {
          my $anonstepnum = 1 + grep { $_ =~ m/^$dirprefix$steptype/ } keys %$seenseeds;
          $seenseeds->{$step} = $anonstepnum;
        }
        my $replace = $dirprefix . $steptype . "." . $seenseeds->{$step};
        $l =~ s/$step/$replace/;
      }
    }
    print "$prefix$l\n";
  }
  return \@depsinvars;
}
sub print_log {
  my $prefix = shift;
  my $s = shift;
  my $stepdir = get_stepdir($s);
  my $logtext = `tail -n3 $stepdir/log.* 2> /dev/null`;
  chomp $logtext;
  foreach my $l (split /\n/, $logtext) {
    print "$prefix$l\n";
  }
}

sub traceback_to_recipe {
  # construct a recipe from a traceback
  my $step = shift;
  my $stepdir = get_stepdir($step);
  mydie "Can't create traceback, $step nonexistent."
    if ! defined $stepdir || ! -e $stepdir;
  my $recipe = { "name" => $step,
                 "vars" => [ split /\n/, load_vars_str($step) ],
                 "deps" => [],
               };
  my $deps = load_depsarr($step);
  foreach my $dep (@$deps) {
    push @{$recipe->{"deps"}}, traceback_to_recipe($dep);
  }
  return $recipe;
}

sub print_details_in_tracebacks {
  my $prefix = shift;
  my $step = shift;
  my $seenseeds = shift;

  my $stepstr = $anonymize ?
    $dirprefix . get_steptype($step) . "." . $seenseeds->{$step} :
    $step;
  my $indent = $show_tree_in_traceback ? "+- " : "";
  print "$prefix$indent$stepstr\n";
  my @kws; # space-delimited keywords
  if ($show_jobid) {
    my $jid = load_jobid($step);
    push @kws, $jid if defined $jid && $jid ne "-";
  }
  push @kws, load_status($step) || "" if $show_status;
  push @kws, show_dir($step) || "" if $showdir;
  push @kws, compiled_tag_string($step) || "" if $show_tag;
  $indent = $show_tree_in_traceback ? "|  | " : "";
  print $prefix.$indent."Job: @kws\n" if 0 < scalar @kws;
  my $depsinvars = print_vars($prefix.$indent, $step, $seenseeds) if $show_vars;
  print_log($prefix.$indent, $step) if $show_log;
  return $depsinvars;
}

sub traceback {
  my $prefix = shift;
  my $step = shift;
  my $seenseeds = shift;

  return if $avoid{$step} || $ignore{$step};
    # explicit avoiding of individual steps
  return if $ignore{get_steptype($step)}; # avoiding steps of a given type

  if (! defined $seenseeds->{$step}) {
    my $steptype = get_steptype($step);
#     print STDERR "Known steps: ", join(',', keys %$seenseeds), "\n" if $debug;
    my $anonstepnum = 1 + grep { $_ =~ m/^$dirprefix$steptype/ } keys %$seenseeds;
    $seenseeds->{$step} = $anonstepnum;
  }
  my $depsinvars = print_details_in_tracebacks($prefix, $step, $seenseeds) // [];

  my $depsarr = load_depsarr($step);
  if (defined $depsarr) {
    my @deps = uniq( @$depsinvars, sort @$depsarr);
    # if this step is reused, all deps are also reused
    # (this is useful in 'tb -s')
    if ($reuse{$step}) {
      foreach my $dep (@deps) {
        $reuse{$dep} = 1;
      }
    }
    my $indent = $show_tree_in_traceback ? "|  " : "";
    return if !$recurse;
    foreach my $dep (@deps) {
      traceback($prefix.$indent, $dep, $seenseeds);
    }
  } else {
    print STDERR "Warning: failed to find deps of $step\n";
  }
}

sub traceindex {
  # Find recursively all users of the step and all their users.
  my $prefix = shift;
  my $step = shift;
  my $indexfield = shift;

  return if $avoid{$step} || $ignore{$step};
    # explicit avoiding of individual steps
  return if $ignore{get_steptype($step)}; # avoiding steps of a given type

  print_details_in_tracebacks($prefix, $step);

  my $users = $idx->{$indexfield}->{$step};
  return if !defined $users;
  my @users = keys %$users;
  my $indent = $show_tree_in_traceback ? "|  " : "";
  return if !$recurse;
  foreach my $usr (@users) {
    traceindex($prefix.$indent, $usr, $indexfield);
  }
}


sub mk_backlinks {
  my $step = shift;

  return if $avoid{$step} || $ignore{$step};
    # explicit avoiding of individual steps
  return if $ignore{get_steptype($step)}; # avoiding steps of a given type

  my $indent = $show_tree_in_traceback ? "+- " : "";
  my $deps = load_depsarr($step);
  foreach my $dep (@$deps) {
    my $depdir = get_stepdir($dep);
    print STDERR "In $step adding symlink to $depdir\n" if $verbose;
    chdir_to_stepdir($step); # the recursion changes the dirs...
    if (! -l $dep) {
      my $success;
      my $symlink_created = eval { $success = symlink($depdir, $dep); 1; };
        # the eval trick is said to catch exceptions on non-symlinking systems
      print STDERR "Failed to symlink $dep from $step.\n"
        if !$success || !$symlink_created;
    }
    mk_backlinks($dep);
  }
}

sub recognize_command {
  my $command = shift;
  return undef if !defined $command;
  $command = $expand_abbrev{$command};
  # no implicit acceptance. Always list the command in expand_abbrev, even if
  # it has no abbreviation (map it to itself)
  return $command;
}

sub mkdiruniq {
  my $prefix = shift;
  my $suffix = shift;

  my $dirnum = 1;
  my $tryname = mkdiruniq2($prefix, $suffix, $dirnum);
  while (-e $tryname) {
    $dirnum++;
    $tryname = mkdiruniq2($prefix, $suffix, $dirnum);
  }
  if (mkdir($tryname)) {
    return $tryname;
  } else {
    print STDERR "Failed to create the directory $tryname, $!";
    exit 1;
  }
}
sub mkdiruniq2 {
  my $prefix = shift;
  my $suffix = shift;
  my $num = shift;
  my $forhash = $prefix.$suffix.$num;
  my $hash = substr(md5_hex($forhash), 0, 8);
  return $prefix.$hash.$suffix;
}

sub absolutize_within_maindir {
  # return the absolute path to the file given
  # using a path relative to main directory
  my $fn = shift;
  return $fn if $fn =~ /^[\/~]/; # absolute path is already ok
  guess_maindir();
  return File::Spec->catfile($maindir, $fn); # this is the real meaning of absolutize_within_maindir
}

sub get_stepdir {
  my $step = shift;
  # given a step name, scan all the subdirs and return full path
  # to the step's directory
  confess if !defined $step;
  return $idx->{$step . "path"} if defined $idx->{$step . "path"};
  # scan all subdirs
  for my $dir (@subdirs) {
    my $path = File::Spec->catfile($dir, $step);
    return $path if -e $path;
  }
  return undef;
}

sub absolutize_within_stepdir {
  # return the full path of a file given relative to the stepdir of a step
  my $step = shift;
  my $fn = shift;
  return File::Spec->catfile(get_stepdir($step), $fn);
}

sub step_valid {
  my $step = shift;
  my $stepdir = get_stepdir($step);
  return 0 if !defined $stepdir;
  if ($debug) {
    print STDERR "Checking validity of $step, CWD: ", cwd(), "\n";
    print STDERR "  stepdir: ", $stepdir, "\n";
    print STDERR "  maindir: ", $maindir, "\n";
  }
  return stepdir_valid($stepdir);
}

sub stepdir_valid {
  # checks if the given directory feels like an eman step
  my $stepdir = shift;
  return -e File::Spec->catfile($stepdir, "eman.status");
    # This test used to check for eman.seed and eman.vars, but that makes
    # things harder for forged steps.
}

sub get_steptype {
  my $step = shift;
  my $oldstep = $step;
  $step =~ s/^(|.*\/)\Q$dirprefix\E([^.]*).*/$2/;
  confess "Failed to get steptype from: $step" if $step eq $oldstep;
  return $step;
}

sub load_status {
  my $step = shift;
  my $status = try_load(absolutize_within_stepdir($step, "eman.status"));
  ###!!! For some reason, adding 'or "NONEXISTENT"' directly to the above line did not work.
  $status = "NONEXISTENT" if(!defined($status));
  return $status;
}
sub load_tag {
  my $step = shift;
  return try_load(absolutize_within_stepdir($step, "eman.tag"));
}
sub load_tag_hash {
  my $step = shift;
  my $tagstr = load_tag($step);
  return {} if ! defined $tagstr;
  my %out = map { ($_, 1) } grep { /./ && $_ ne " "} split /(\s|\n)+/, $tagstr;
  return \%out;
}

sub compiled_tag_string {
  # used when displaying tags, includes autotags and manual tags
  my $step = shift;
  # my $tags = load_tag_hash($step);
  my $tags = $idx->{"STEP_TO_ALLTAGS"}->{$step};
  return join(" ",
    ( sort {$a cmp $b} keys %$tags ),
    # ( sort {$a cmp $b} keys %$autotags ),
  );
}


sub load_arr {
  my $step = shift;
  my $filename = shift;
  my $str = try_load(absolutize_within_stepdir($step, $filename));
  my $arr;
  if (defined $str) {
    my @lines = split /\n/, $str;
    $arr = [];
    my %seen = ();
    foreach my $d (@lines) {
      next if $seen{$d};
      push @$arr, $d;
      $seen{$d} = 1;
    }
  }
  return $arr;
}

sub load_depsarr {
  my $step = shift;
  return load_arr($step, "eman.deps");
}

sub load_vars_str {
  my $step = shift;
  return try_load(absolutize_within_stepdir($step, "eman.vars"));
}
sub load_vars_hash {
  # load (and unescape) eman variables
  my $step = shift;
  my $varsstr = load_vars_str($step);
  my %varshash = ();
  if (defined $varsstr) {
    foreach my $pair (split /\n/, $varsstr) {
      next if $pair eq "";
      my ($varname, $val) = split(/=/, $pair, 2);
      $varshash{$varname} = var_bash_unescape($val);
    }
  }
  return \%varshash;
}
sub save_vars_hash {
  # overwrite all saved vars with the given hash
  my $step = shift;
  my $outvars = shift;

  my $vars_str = "";
  foreach my $varname (sort {$a cmp $b} keys %$outvars) {
    $vars_str .= "$varname=".var_bash_escape($outvars->{$varname})."\n";
  }
  #print STDERR "Saving $vars_str\n";
  #print STDERR "Saving into ", absolutize_within_stepdir($step, "eman.vars"), "\n";
  save(absolutize_within_stepdir($step, "eman.vars"), $vars_str);
}


sub load_jobid {
  my $step = shift;
  return try_load(absolutize_within_stepdir($step, "eman.jobid"));
}
sub show_disk_usage {
  my $step = shift;
  my $stepdir = get_stepdir($step);
  my $du = `du -sh $stepdir 2>/dev/null | cut -f1`;
  chomp $du;
  return $du;
}
sub show_dir {
  my $s = shift;
  my $steppath = $idx->{$s . "path"};
  if (!defined $steppath) {
    print STDERR "Warning: $s not know (local?). Please reindex.\n";
    return "L?";
  }
  $steppath =~ s/\/$s//; # remove step directory
  if (abs_path($steppath) ne $maindir) {
    # step is not from around here
    $steppath =~ s/$maindir\///; # strip playground path
    if (-l "$maindir/$steppath") {
      return "R/".$steppath;
    } else {
      return "S/".$steppath;
    }
  } else {
    return "L";
  }
}

sub canon_stepdir {
  my $step = shift;
  # interprets uniquely supplied steps
  my $s = $step;
  $s = $1 if $step =~ /^.*\/([^\/]+)\/?/;
  $s = guess_step_from_hashdate($s);
  mydie "Not a valid step: $step" if !defined $s;
  return $s;
}

sub guess_maindir {
  # ensure the variable maindir is set
  return if defined $maindir;
  die "../$seedsdir and ./$seedsdir exist, I'm confused."
    if -e "../$seedsdir" && -e "./$seedsdir";
  # search upwards in the tree
  my $up = "./";
  while ( -d $up && ! -e $up.$seedsdir) {
    $up .= "../";
  }
  die "Failed to guess eman main dir (failed to find '$seedsdir' up in the CWD path.)"
    if ! -e $up.$seedsdir;
  # store the absolute path of the maindir
  $maindir = abs_path($up);  # touch filesystem
}

sub guess_stepname_from_dir {
  my $dir = shift;
  # given a subdir of a stepdir, return the stepdir name (or undef)
  # search upwards in the tree
  # since subdirectories are supported, this is a heuristic based on stepname format
  my $oldwd = cwd();
  chdir $dir or die "Failed to guess stepdir from $dir (not a dir)";
  my $up = "./";
  my $out = undef;
  while ( -d $up && ! -e $up."/".$seedsdir) {
    my $bup = basename(abs_path($up));
    $out = $bup if $bup =~ m/^$dirprefix.*\d{8,8}-\d{4,4}$/;
    $up .= "../";
  }
  if (! -e $up."/".$seedsdir) {
    $out = undef;
  }
  chdir($oldwd) or die "Failed chdir back to $oldwd";
  return $out;
}

sub guess_stepname_from_pathname {
  my $pathname = shift;
  if ( -d $pathname ) {
    return guess_stepname_from_dir($pathname);
  } else {
    return guess_stepname_from_dir(dirname($pathname));
  }
}


sub chdir_to_maindir {
  my $oldwd = cwd();
  guess_maindir();
  mychdir($maindir);
  return $oldwd;
}
sub chdir_to_stepdir {
  my $step = shift;
  my $oldwd = cwd();
  my $path = get_stepdir($step);
  if (-e $path) {
    chdir($path) or die "Failed to chdir to $path";
  } else {
    confess "Stepdir for $step not found.";
  }
  return $oldwd;
}
sub mychdir {
  my $d = shift;
  my $oldwd = cwd();
  chdir($d) or confess "Failed to chdir to $d";
  return $oldwd;
}

sub guess_step {
  my $key = shift;
  my $step = guess_step_from_hashdate($key);
  if (!defined $step) {
    # guess from jobid
    $step = $idx->{"jid$key"};
  }
  if (!defined $step && -e $resultsfile) {
    # guess from results file
    my $resultstext = load($resultsfile);

    my @resultsmatches = grep { /$key/ } split /\n/, $resultstext;
    my $step_to_text;
    foreach my $l (@resultsmatches) {
      my ($step, $rest) = split /\t/, $l, 2;
      if (defined $step_to_text->{$step}) {
        push @{$step_to_text->{$step}}, $rest;
      } else {
        $step_to_text->{$step} = [ $rest ];
      }
    }

    my @steps = keys %$step_to_text;
    if (1<scalar(@steps)) {
      print STDERR "Ambiguous in results file: $key:\n";
      foreach my $s (@steps) {
        print STDERR "$s:\n";
        print STDERR join("", map { "  $_\n" } @{$step_to_text->{$s}});
      }
      exit 1;
    }
    $step = $steps[0]; # pick the first and only
  }
  if (!defined $step) {
    # guess from dir listing
    my @dirs;
    for my $subdir (@subdirs) {
      push @dirs, grep { /$key/ } glob("$subdir/$dirprefix*.*.[0-9]*");
    }
    # we do not use the preloaded index, because it contains only valid exps.
    if (1<scalar(@dirs)) {
      print STDERR "Ambiguous in dir listing: $key:\n";
      print STDERR join("", map { "  $_\n" } @dirs);
      exit 1;
    }
    $step = guess_step_from_hashdate($dirs[0]) if 1==scalar @dirs;
  }
  # only recommend --reindex if not already specified
  my $try_reindex = $reindex ? "" : "\nTry --reindex.";

  confess "Failed to guess step from: $key$try_reindex" if !defined $step;
  return $step;
}


sub guess_step_from_hashdate {
  # this is messy :-(
  my $key = shift;
  print STDERR "Guessing step from hash and date: $key\n" if $debug;
  for my $subdir ('.', @subdirs) {
    if (-d "$subdir/$key") {
      # directory name explicitly given, check if it is indeed a step directory
      # this branch is also used for '.', i.e. the current step dir...
      my $step = guess_stepname_from_dir("$subdir/$key");
      return $step if -e "$subdir/$key/eman.seed";
    }
  }
  # try to interpret the stepname relative to main dir
  my $dkey = absolutize_within_maindir($key);
  if (-d $dkey) {
    my $step = basename(File::Spec->rel2abs($dkey));
    return $step if -e $dkey."/eman.seed";
  }
  # scan index if there is such a step
  my %stepnames = map { ($_,1) }
                  map { s/(\Q$dirprefix\E[^\.]+\.).*/$1/; $_; }
                  grep { /^\Q$dirprefix/ } # this is a forward index
                  keys %$idx;
  foreach my $pref (keys %stepnames) {
    if (-d $pref.$key) {
      return $pref.$key;
    }
  }
  return undef; #couldn't confirm
}

sub qstat {
  # Call the SGE's command qstat and in its output, try to replace job names by step names.
  # Rely on one particular qstat output format (probably not granted on other platforms/versions).
  open(QSTAT, 'qstat |') or die("Cannot pipe from qstat: $!");
  my @fieldnames = ('jobid', 'prior', 'name', 'user', 's', 'date', 'time', 'machine', 'tags');
  my @rows;
  while(<QSTAT>)
  {
      if(m/^(\d+)\s+(0\.\d+)\s+(\S+)\s+(\w+)\s+(\w+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(.*)/)
      {
          chomp;
          my @fields = split(/\s+/, $_);
          # If the job is not running the machine-name field will be empty, we will not recognize it
          # and we will get the next field instead, which is, usually, just the number "1" (number of slots).
          splice(@fields, 7, 0, '') if($fields[7] =~ m/^\d+$/);
          push(@rows, \@fields);
      }
  }
  close(QSTAT);
  # Guess step names and figure out column widths.
  my @lengths = map {length($_)} (@fieldnames);
  foreach my $row (@rows)
  {
      # Try to guess the step name. (Will do no harm if the job does not have to do with eman.)
      if(eval { guess_step($row->[0]) })
      {
          $row->[2] = guess_step($row->[0]);
          # Replacing the 'slots' column provided by qstat:
          $row->[8] = compiled_tag_string($row->[2]);
          if(length($row->[8])>80)
          {
              $row->[8] = substr($row->[8], 0, 77).'...';
          }
      }
      # Change the date format so we know for sure what is month and day.
      if($row->[5] =~ m-(\d+)/(\d+)/(\d+)-)
      {
          $row->[5] = "$3-$1-$2";
      }
      # Queue names are unnecessarily long. Convert them to machine names.
      if($row->[7] =~ m/^all.q@([a-z0-9]+)\.ufal\.hide/)
      {
          $row->[7] = $1;
      }
      for(my $i = 0; $i<=$#{$row}; $i++)
      {
          my $l = length($row->[$i]);
          if(!defined($lengths[$i]) || $l>$lengths[$i])
          {
              $lengths[$i] = $l;
          }
      }
  }
  # Print the table.
  for(my $i = 0; $i<=$#fieldnames; $i++)
  {
      $fieldnames[$i] = '' if(!defined($fieldnames[$i]));
      print($fieldnames[$i]);
      print(' ' x ($lengths[$i]-length($fieldnames[$i])));
      print($i==$#fieldnames ? "\n" : ' ');
  }
  for(my $i = 0; $i<=$#fieldnames; $i++)
  {
      print('-' x $lengths[$i]);
      print($i==$#fieldnames ? "\n" : '-');
  }
  foreach my $row (@rows)
  {
      my @fields = @{$row};
      for(my $i = 0; $i<=$#fields; $i++)
      {
          $fields[$i] = '' if(!defined($fields[$i]));
          print($fields[$i]);
          print(' ' x ($lengths[$i]-length($fields[$i])));
          print($i==$#fields ? "\n" : ' ');
      }
  }
}

sub add_hash_to_index {
  my $stepname = shift;
  my $hash = shift;
  print STDERR "ADDED: $stepname  -> $hash\n" if $debug;
  $idx->{$stepname} = $hash;
  # multiple steps can have the same hash, so the hash is mapped to a list
  if (defined $idx->{$hash} && ! grep { $_ eq $stepname } @{$idx->{$hash}}) {
    push @{$idx->{$hash}}, $stepname;
  } else {
    $idx->{$hash} = [$stepname];
  }
}
sub remove_step_from_index {
  # this is used only in init() when we realize the step was already available
  # so we assume there is no jid entry for the step
  my $stepname = shift;
  my $hash = $idx->{$stepname};
  delete $idx->{$stepname};
  delete $idx->{$stepname."path"};
  my @removed = grep { $_ ne $stepname } @{$idx->{$hash}};
  $idx->{$hash} = [ @removed ];
}


sub add_fake_step_to_index {
  # used in dry runs
  my $stepname = shift;
  my $vars = shift;
  my $hash = get_hash_from_vars_deps($stepname, $vars, undef);
  add_hash_to_index($stepname, $hash);
}

sub add_stepdir_to_index {
  my $s = shift;
  my $stepname = basename($s);
  my $hash = get_hash_from_dir($s);
  add_hash_to_index($stepname, $hash);
  my $jid = load_jobid($stepname);
  # also store jobid, if available
  if (defined $jid) {
    $idx->{$stepname} = $hash;
    $idx->{"jid$jid"} = $stepname;
    $idx->{$stepname."jid"} = $jid;
  }
  # store the path to step
  $idx->{$stepname."path"} = $s;
}
sub loadidx {
  # load the index file and hash it there and back
  my $idx;
  if (-e $indexfile) {
    $idx = Load(load($indexfile)."\n"); # YAML to Load the string
  }
  return $idx;
}
sub saveidx {
  my $idx = shift;
  my ($h, $tempname) = tempfile("eman.index.tmpXXXXXX", DIR=>$maindir);
  print STDERR "Saving index to $tempname\n" if $debug;
  binmode($h, ":utf8");
  # my $h = my_save($indexfile);
  print $h Dump($idx);
  close $h;
  print STDERR "Moving index from $tempname to $indexfile\n" if $debug;
  rename($tempname, $indexfile)
    or print STDERR "Failed to move $tempname to $indexfile";
  chmod 0644, $indexfile;
}

sub get_hash_from_dir {
  my $step = shift;

  my @vars = split /\n/, load($step."/eman.vars");
  #my @deps = split /\n/, load($step."/eman.deps");
  return get_hash_from_vars_deps(basename($step), \@vars, undef);
}
sub get_hash_from_vars_deps {
  my $name = shift;
  my $vars = shift;
  my $deps = shift;

    # deps are totally ignored, we assume they are implied by vars
  # avoid considering the name of ourselves significant in content check
  my @usevars = @$vars;
  @usevars =
    grep { ! /^[^=]+=''$/ } grep { ! /^[^=]+=""$/ } # skip empty-valued vars
    grep { /^[^=]+=./ }  # skip empty-valued vars
    grep { ! /^EMAN_/ } # skip eman's internal variables (such as EMAN_CORES)
    grep { /./ } # skip empty lines
    map  {s/$name/---SELF---/g; $_}
    @usevars;
  # include steptype in the hash to distinguist vars-less steps
  my $steptype = get_steptype($name);
  my $hash =  md5_hex($steptype, sort @usevars);
  print STDERR "STEPTYPE $steptype, USEVARS: @usevars\n  -> $hash\n" if 1 && $debug;
  return $hash;
}

sub all_steps {
  # returns an array of all steps mentioned anywhere
  my %steps_to_list = ();
  foreach my $s (keys %$idx) {
    next if $s !~ /^\Q$dirprefix/; # this is a reverse index
    next if $s =~ /(jid|path)$/; # this is a job id entry
    $steps_to_list{$s} = 1;
  }
  foreach my $metalist ('USED_BY', 'DERIVED_FROM', 'DERIVATIVES') {
    if (defined $idx->{$metalist}) {
      # eagerly collect also all steps mentioned in deps
      foreach my $d (keys %{$idx->{$metalist}}) {
        $steps_to_list{$d} = 1;
        my $sources = $idx->{$metalist}->{$d};
        next if !defined $sources;
        foreach my $s (keys %$sources) {
          $steps_to_list{$s} = 1;
        }
      }
    }
  }
  return keys %steps_to_list;
}

sub get_step_date {
  my $step = shift;
  $step =~ s/.*\.([^\/]*)-.*/$1/;
  return $step;
}

# compare steps by timestamp
sub compare_steps {
  my ( $first, $second ) = @_;
  $first =~ s/.*\.([^\/]*)\/*/$1/;
  $second =~ s/.*\.([^\/]*)\/*/$1/;
  my ( $first_date, $first_time ) = split '-', $first;
  my ( $second_date, $second_time ) = split '-', $second;
  if ($second_date != $first_date) {
    return $second_date <=> $first_date;
  } else {
    return $second_time <=> $first_time;
  }
}

# routines for autotags

# One line of the config file is called a 'rule' and it can create one autotag.
# The autotag is constructed using of sequence of regexes, each applied on the
# output of the previous one, starting with the vars string.

sub load_autotag_rules {
# autotag_rules->{steptype} = [ [list of regexes producing one tag],
#   [list of regexes producing another tag] ]
  my $inf = shift;
  my $h = my_open($inf);
  my $out;
  my $nr = 0;
  while(<$h>) {
    $nr++;
    chomp;
    next if /^\s*#/ || /^\s*$/;
    my @cols = split / *\t */;
    my $steptype = shift @cols;
    my $sources = shift @cols;
    my @sources = split(/\|/, $sources);
    foreach my $source (@sources) {
      $out->{$steptype}->{$source} = [] if !defined $out->{$steptype}->{$source};
      push @{$out->{$steptype}->{$source}}, [ @cols ];
      print STDERR "Autotag rules based on $source of $steptype: $_\n" if $debug;
    }
  }
  close $h;
  return $out;
}

sub reindex_tags {
  # for all steps, removes all autotags and recreates them
  $idx->{'STEP_TO_DIRECT_AUTOTAGS'} = undef; # delete old
  $idx->{'STEP_TO_ALLTAGS'} = undef; # delete old
  # first add 'direct' tags, i.e. manual tags and autotags implied by the rules
  # to individual steps
  foreach my $step (all_steps()) {
    print STDERR "$step: Copying standard tags into index.\n" if $debug;
    # first copy step manual tags to the index
    $idx->{'STEP_TO_ALLTAGS'}->{$step} = load_tag_hash($step);
    # then add the direct autotags
    print STDERR "$step: Adding direct autotags.\n" if $debug;
    my $steptype = get_steptype($step);
    next if ! defined $autotag_rules->{$steptype};
    my $varsstr = load_vars_str($step);
    next if ! defined $varsstr;
    if (defined $autotag_rules->{$steptype}->{"var"}) {
      # there are some tags to be created from individual variables
      foreach my $rule (@{$autotag_rules->{$steptype}->{"var"}}) {
        foreach my $varline (split /\n/, $varsstr) {
          next if $varline eq "";
          my $tag = apply_substitutions_to_subtag($varline, $rule);
          next if $tag eq ""; # blank tag is removed
          $idx->{'STEP_TO_DIRECT_AUTOTAGS'}->{$step}->{$tag} ++;
          $idx->{'STEP_TO_ALLTAGS'}->{$step}->{$tag} ++;
        }
      }
    }
    # if (defined $autotag_rules->{$steptype}->{"inhertags"}) {
    # this is another option: constructing tags from inherited autotags
    # however, this needs to be applied only after inheriting...
  }
  # Add indirect tags, i.e. tags inherited from steps above
  print STDERR "Propagating tags...\n" if $debug;
  my $indexed;
  foreach my $step (all_steps()) {
    next if $indexed->{$step};
    $indexed = add_inherited_tags($indexed, $step);
  }
}

sub add_inherited_tags {
  my $indexed = shift;
  my $step = shift;
  confess if ! defined $indexed || ! defined $step;
  my $deps = load_depsarr($step);
  $deps = [] if !defined $deps;
  $indexed->{$step} = 1; # myself, I am indexed
  print STDERR "$step: @$deps\n" if $debug;
  foreach my $dep (@$deps) {
    print STDERR "for $step: $dep: ", compiled_tag_string($dep), "\n" if $debug;
    # ensure all predecessors inherited theirtags
    $indexed = add_inherited_tags($indexed, $dep) if ! $indexed->{$dep};
    # inherit our tags from the dep
    # TODO here is the place to control what is being inherited
    # based on a not-yet-specified types of rules in eman.autotag
    foreach my $tag (keys %{$idx->{'STEP_TO_ALLTAGS'}->{$dep}}) {
      my $inhtag = $tag;
      # DZ: Experimental rule type: source = step type instead of 'vars'
      # It means that the regular expressions will be applied to tags inherited from steps of that type.
      # One can block inheriting by the expression /.*//.
      my $steptype = $step;
      $steptype =~ s/^s\.(.*?)\..*$/$1/;
      my $inhtype = $dep;
      $inhtype =~ s/^s\.(.*?)\..*$/$1/;
      if (exists $autotag_rules->{$steptype}->{$inhtype}) {
        foreach my $rule (@{$autotag_rules->{$steptype}->{$inhtype}}) {
          $inhtag = apply_substitutions_to_subtag($inhtag, $rule);
        }
      }
      next if $inhtag eq ''; # blank tag is removed
      print STDERR "  + $inhtag\n" if $debug;
      $idx->{'STEP_TO_ALLTAGS'}->{$step}->{$inhtag}
        += $idx->{'STEP_TO_ALLTAGS'}->{$dep}->{$tag};
    }
  }
  return $indexed;
}

sub apply_substitutions_to_subtag
{
    my $tag = shift; # source: line of eman.vars or inherited tag
    my $rule = shift; # reference to array of regular expressions
    my $first_regex = 1;
    foreach my $regex (@{$rule})
    {
        print STDERR "Eval:  \$tag =~ s$regex;\n" if $debug;
        if ($first_regex)
        {
            # the first regex is also a selector, if it does not find
            # anything, skip the whole line
            eval "\$tag =~ s$regex or \$tag = '';";
            $first_regex = 0;
        }
        else
        {
            # all right to leave the tag unchanged
            eval "\$tag =~ s$regex;";
        }
    }
    return $tag;
}
# end of routines for autotags



# routines for tablemaker
package Summarizer;
sub interpret {
  my $self = shift; # supply attributes
  my $lines = shift;

  for my $f (qw/required forbidden rows cols print_max_marks/) {
    # define as blank and trim
    $self->{$f} = "" if !defined $self->{$f};
    $self->{$f} =~ s/^[ \n\t]*|[ \n\t]*$//g;
  }
  for my $f (qw/rowsort colsort/) {
    # trim only if defined
    next if !defined $self->{$f};
    $self->{$f} =~ s/^[ \n\t]*|[ \n\t]*$//g;
  }

  $self->{reqtoksf} = [ grep { /./ } split /[ \n\t]+/, $self->{required} ];
  $self->{forbtoksf} = [ grep { /./ } split /[ \n\t]+/, $self->{forbidden} ];
  $self->{rowtoksf} = [ grep { /./ } split /[ \n\t]+/, $self->{rows} ];
  $self->{coltoksf} = [ grep { /./ } split /[ \n\t]+/, $self->{cols} ];

  $self->{blankvalue} ||= "-";
  $self->{verbose} ||= 0;

  bless $self;
  my $table = $self->scan($lines);
  return $table;
}

sub collect_tokens {
  # given a regular expression, collect all occurrences of it
  # special flags can be given using a few letters followed by ^ (not part of
  # the regexp), e.g. u^mytoken to set 'uniq' flag
  # Flags:
  #   u ... uniq, ignore repetitive occurrences of the token
  #   c ... uniq -c, count repetitive occurrences of the token
  #   i ... insensitive, ignore case # not yet implemented
  #   f ... first occurrence only, don't collect all
  my $self = shift;
  my $origtokenre = shift;
  my $line = shift;

  $line .= " "; # just to allow easier matching at EOL

  my @out = ();

  # remove flags from origtokenre
  $origtokenre =~ s/^([uicf])\^//;
  my $flags = $1;
  $flags = "" if ! defined $flags;

  $origtokenre =~ s/^(\^)//;
  my $match_token_start_re = (defined $1 && $1 eq "^" ? "\\s" : "");

  print STDERR "Searching for $origtokenre in $line.\n" if $debug;
  while ($line =~ /$match_token_start_re$origtokenre/) {
    my @matches = map {substr $line, $-[$_], $+[$_] - $-[$_]} (1..$#-);
    # delete this token occurrence
    my $oldline = $line;
    substr($line, $-[0], $+[0] - $-[0], "");
    die "Avoiding loop with re $origtokenre and line: $line" if $line eq $oldline;
    my $tokenre = $origtokenre;
    if ($tokenre =~ /\(/) {
      print STDERR "Token $tokenre MATCHES: @matches\n" if $debug;
      foreach my $m (@matches) {
        $tokenre =~ s/\((?!\?:)[^\(\)]+\)/$m/;
      }
    }
    push @out, (defined $self->{tokenmap}->{$tokenre} ? $self->{tokenmap}->{$tokenre} : $tokenre);
  }

  if ($flags =~ /f/) {  # first occurrence only
    return () if 0 == scalar @out;
    return $out[0];
  } elsif ($flags =~ /u/) {  # uniq the occurrences
    return () if 0 == scalar @out;
    my %uniq = map { ($_, 1) } @out;
    return sort {$a cmp $b} keys %uniq;
  } elsif ($flags =~ /c/) {  # count the number of occurrences
    return () if 0 == scalar @out;
    return ( scalar(@out)."*".$out[0] );
  } else {
    return @out;
  }
}

sub scan {
  my $self = shift;
  my $lines = shift;

  my $out = "";

  $out .= "Common properties: ".join(" ", @{$self->{reqtoksf}})."\n";
  $out .= "Forbidden properties: ".join(" ", @{$self->{forbtoksf}})."\n";

  my $col_to_pick = $self->{data_column};

  my %coldef; my %rowdef;
  my @coldef; my @rowdef;
  my %table;
  my %tableinfo; # for reporting conflicts
  my %showtable; # for showing something else than results

  my %used = ();
  LINE: foreach my $line (@$lines) {
    foreach my $r (@{$self->{reqtoksf}}) {
      if ($line !~ /$r/) {
        $out .= "Removing due to missing $r: ".$line."\n"
          if $self->{verbose} >= 3;
        next LINE;
      }
    }
    foreach my $f (@{$self->{forbtoksf}}) {
      if ($line =~ /$f/) {
        $out .= "Removing due to forbidden $f: ".$line."\n"
          if $self->{verbose} >= 3;
        next LINE;
      }
    }
    $out .= "Picking rowids and colids from: ".$line."\n"
      if $self->{verbose} >= 4;
    my @rowid = ();
    foreach my $temprt (@{$self->{rowtoksf}}) {
      my $rt = $temprt;
      push @rowid, ($self->collect_tokens($rt, $line));
    }
    my @colid = ();
    foreach my $ct (@{$self->{coltoksf}}) {
      push @colid, ($self->collect_tokens($ct, $line));
    }

    my $rowid = "@rowid";
    my $colid = "@colid";
    $out .= "  got: $rowid   and   $colid\n"
      if $self->{verbose} >= 4;
    if (!defined $rowdef{$rowid}) {
      push @rowdef, $rowid;
      $rowdef{$rowid} = 1;
    }
    if (!defined $coldef{$colid}) {
      push @coldef, $colid;
      $coldef{$colid} = 1;
    }
    my $pos = "$rowid\t$colid";
    my @cols = split /\t/, $line;
    my $value = $cols[$col_to_pick];
    my $showvalue;
    if ($self->{show} eq "%f") {
      $showvalue = $value;
    } elsif ($self->{show} eq "%s") {
      $showvalue = $cols[0];
    } elsif ($self->{show} eq "%S") {
      $showvalue = $cols[0];
      $showvalue =~ s/^\Q$dirprefix\E[-_a-z9-0]+\.//;
    } elsif ($self->{show} eq "%t") {
      $showvalue = $cols[1];
    }

    my $thisinfo = [@cols];
    if (defined $table{$pos} && !defined $self->{collectdelim}
        && ($table{$pos} ne $value || $self->{verbose} >= 2)) {
      $out .= "Replaced: ".join("\t", @{$tableinfo{$pos}})."\n";
      my @with = @cols;
      $with[4] = "--- identical ---" if $with[4] eq $tableinfo{$pos}->[4];
      $out .= "    With: ".join("\t", @with)."\n";
      delete $used{"@rowid\t@colid\t$tableinfo{$pos}"};
    }
    if (defined $self->{collectdelim}) {
      if (defined $table{$pos}) {
        $table{$pos} .= $self->{collectdelim};
        $showtable{$pos} .= $self->{collectdelim};
      }
      $table{$pos} .= $value;
      $showtable{$pos} .= $showvalue;
    } else {
      $table{$pos} = $value;
      $showtable{$pos} = $showvalue;
      # $out.="REGISTERING: $pos  ==> $value\n";
    }
    $tableinfo{$pos} = $thisinfo;
    $used{"@rowid\t@colid\t$line"} = 1;
  }
  $out .= "\n".join("", map {"Using: ".$_."\n"} sort keys %used)
    if ($self->{verbose} || defined $rowdef{""} || defined $coldef{""})
      && ($self->{verbose} >= 1);
  $out .= "\n";
  my @sortedrowdef;
  if (defined $self->{rowsort}) {
    @sortedrowdef = sort { # $out.="SORT\na: $a\t$self->{rowsort}\n";
          ( take_just_number($table{"$b\t$self->{rowsort}"}) || 0 )
      <=> ( take_just_number($table{"$a\t$self->{rowsort}"}) || 0 ) } @rowdef;
  } else {
    @sortedrowdef = sort {$a cmp $b } @rowdef;
  }
  my @sortedcoldef;
  if (defined $self->{colsort}) {
    @sortedcoldef = sort { # $out.="SORT\na: $a\t$self->{colsort}\n";
          ( take_just_number($table{"$self->{colsort}\t$b"}) || 0 )
      <=> ( take_just_number($table{"$self->{colsort}\t$a"}) || 0 ) } @coldef;
  } else {
    @sortedcoldef = sort { $a cmp $b } @coldef;
  }
  # Prepare the table
  my @tab;
  my @showtab;
  my @mark;
  my $firstcolwidth = 0;
  my @colwidth = map {length($_)} @coldef;
  for(my $r=0; $r<=$#sortedrowdef; $r++) {
    my $row = $sortedrowdef[$r];
    $firstcolwidth = length($row) if length($row) > $firstcolwidth;
    my $val_to_colidx = undef;
    for(my $c=0; $c<=$#sortedcoldef; $c++) {
      my $col = $sortedcoldef[$c];
      my $pos = "$row\t$col";
      my $thisval;
      my $showthisval;
      if (defined $table{$pos}) {
        $thisval = $table{$pos};
        $showthisval = $showtable{$pos};
      } else {
        $thisval = $self->{"blankvalue"};
        $showthisval = $self->{"blankvalue"};
      }
      $tab[$r][$c] = $thisval;
      $showtab[$r][$c] = $showthisval;
      push @{$val_to_colidx->{$thisval}}, $c;
      $colwidth[$c] = length($showthisval)
        if length($showthisval) > $colwidth[$c];
    }
    my @sortedvals = sort {take_just_number($b)<=>take_just_number($a)}
                     keys %$val_to_colidx;
    foreach my $c (@{$val_to_colidx->{$sortedvals[0]}}) {
      $mark[$r][$c] = "^"; # mark this node as horizontal maximum
    }
  }
  for(my $c=0; $c<=$#sortedcoldef; $c++) {
    my $val_to_rowidx = undef;
    for(my $r=0; $r<=$#sortedrowdef; $r++) {
      push @{$val_to_rowidx->{$tab[$r][$c]}}, $r;
    }
    my @sortedvals = sort {take_just_number($b)<=>take_just_number($a)}
                       keys %$val_to_rowidx;
    foreach my $r (@{$val_to_rowidx->{$sortedvals[0]}}) {
      $mark[$r][$c] = defined$mark[$r][$c]?"*":">";
        # mark this node as ultimate or vertical maximum
    }
  }

  # Print column headers
  $out .= " " x $firstcolwidth; # pad the first column of the first row
  for(my $c=0; $c<=$#sortedcoldef; $c++) {
    my $col = $sortedcoldef[$c];
    my $pad = " " x ($colwidth[$c] - length($col));
    $out .= "\t$col$pad";
    $out .= " " if $self->{print_max_marks};
  }
  $out .= "\n";

  # Print the table
  for(my $r=0; $r<=$#sortedrowdef; $r++) {
    my $row = $sortedrowdef[$r];
    my $pad = " " x ($firstcolwidth - length($row));
    $out .= "$row$pad";
    for(my $c=0; $c<=$#sortedcoldef; $c++) {
      my $showthisval = $showtab[$r][$c];
      my $pad = " " x ($colwidth[$c] - length($showthisval));
      $out .= "\t$pad$showthisval";
      if ($self->{print_max_marks}) {
        $out .= defined $mark[$r][$c] ? $mark[$r][$c] : " ";
      }
    }
    $out .= "\n";
  }
  $out .= "\n";
  return $out;
}
sub take_just_number {
  my $s = shift;
  return if !defined $s;
  my $outs = $s;
  $outs =~ s/[^-.0-9].*//;
  return 0 if $outs eq "-";
  return $outs if $outs ne "";
  return $s;
}
package main;


sub tabulate {
  # convert eman.tabulate into eman.niceresults
  my @results = grep { /./ } split /\n/, load("eman.results");
  my $inf = "eman.tabulate";
  my $h = my_open($inf);
  my $outh = my_save("eman.niceresults");
  my $nr = 0;
  my $waserror = 0;
  while (<$h>) {
    $nr++;
    if (/^TABLE$/) {
      my $startnr = $nr;
      my $gotend = 0;
      my $specs = {};
      while (<$h>) {
        $nr++;
        next if /^\s*#/ || /^\s*$/; # skip comments and blank lines
        chomp;
        if (/^ENDTABLE$/) {
          $gotend = 1;
          last;
        }
        if (/^TABLE/) {
          print STDERR "$inf:$nr: Warning TABLE within TABLE starting at $startnr\n";
          $waserror ++;
          next;
        }
        if (/^(forbidden|required|cols|rows|rowsort|colsort|verbose|print_max_marks|collectdelim|show):(.*)$/) {
          my $k = $1;
          my $v = $2;
          $specs->{$k} .= "\n" if defined $specs->{$k};
          $specs->{$k} .= $v;
        } else {
          print STDERR "$inf:$nr:Unrecognized line: $_\n";
          $waserror ++;
        }
      }
      die "$inf:$nr: End of file in TABLE starting at $startnr" if ! $gotend;
      $specs->{"data_column"} = 3;
      $specs->{"show"} = "%f" if !defined $specs->{"show"};
      foreach my $attr (qw(rows cols)) {
        if (!defined $specs->{$attr}) {
          print STDERR "$inf:$nr:Required attribute $attr missing.\n";
          $waserror ++;
        }
      }
      print $outh Summarizer::interpret($specs, \@results);
    } else {
      print $outh $_;
    }
  }
  close $h;
  close $outh;
  return ! $waserror;
}
# end of routines for tablemaker



#------------------------------------------------------------------------------
# Retrieves argument of a filtering command in eman select. Dies if argument
# not found.
#------------------------------------------------------------------------------
sub get_eman_select_arg
{
    my $args = shift; # array reference (array will be modified)
    my $arg = shift(@{$args});
    if(!defined($arg))
    {
        mydie "usage: eman select <command> [arg] [<command> [arg][...]]";
    }
    return $arg;
}



#------------------------------------------------------------------------------
# Filters a list of steps according to criteria specified in the "eman select"
# syntax. Returns the filtered list of steps. Does not print anything (unlike
# select_steps() below).
#------------------------------------------------------------------------------
sub filter_steps
{
    my $steps = shift; # array reference
    my @steps = sort { compare_steps($a, $b) } @{$steps};
    print STDERR "Filtering ", join(" ", @steps), "\n" if $debug;
    my @args = @_;
    # Filter without arguments returns all input steps.
    while (@args)
    {
        my $cmd = shift @args;
        given ($cmd)
        {
            # Negation of the following filters.
            when ("not")
            {
                my @initial_steps = @steps;
                @steps = filter_steps(\@steps, @args);
                my %filtered; map {$filtered{$_}++} (@steps);
                @steps = grep {!exists($filtered{$_})} (@initial_steps);
                splice(@args); # already used to compute the argument of the negation
            }
            # Only DONE steps.
            when ("d") { @steps = grep { load_status($_) eq 'DONE' } @steps; }
            # Only FAILED steps.
            when ("f") { @steps = grep { load_status($_) eq 'FAILED' } @steps; }
            # Only INITED steps.
            when ("i") { @steps = grep { load_status($_) eq 'INITED' } @steps; }
            # Only PREPARED steps.
            when ("p") { @steps = grep { load_status($_) eq 'PREPARED' } @steps; }
            # Only RUNNING steps.
            when ("r") { @steps = grep { load_status($_) eq 'RUNNING' } @steps; }
            # Only last n steps (order defined by compare_steps() called above).
            # (In fact it is the reversed order because we take the first n elements of the array.)
            when ("l")
            {
                my $n = get_eman_select_arg(\@args);
                @steps  = @steps[0 .. min($n - 1, $#steps)];
            }
            # Only last 10 steps.
            when ("lh") { @steps = @steps[0 .. min(9, $#steps)]; }
            # Only steps in given status.
            when ("s")
            {
                my $status = get_eman_select_arg(\@args);
                use 5.010;
                @steps = grep { uc(load_status($_)) eq uc($status) } @steps;
            }
            # Only steps of given type.
            when ("t")
            {
                my $type = get_eman_select_arg(\@args);
                @steps = grep { get_steptype($_) eq $type } @steps;
            }
            # Only steps with given value of a variable (varexpr is VARIABLE=VALUE).
            when ("v")
            {
                my $varexpr = get_eman_select_arg(\@args);
                # Some values of variables are quoted in the variable string.
                # If the user specifies unquoted value, search for the quoted one, too.
                my $qvarexpr = $varexpr;
                $qvarexpr =~ s/=(.*)$/="$1"/;
                my @new_steps;
                for my $step (@steps)
                {
                    my $varsstr = load_vars_str($step);
                    next if ! $varsstr;
                    my @vars = split /\n/, $varsstr;
                    push @new_steps, $step if grep { $_ eq $varexpr || $_ eq $qvarexpr } @vars;
                }
                @steps = @new_steps;
            }
            # Only steps with variable name and/or value matching a regular expression.
            when ("vre")
            {
                my $varexpr = get_eman_select_arg(\@args);
                my @new_steps;
                for my $step (@steps)
                {
                    my $varsstr = load_vars_str($step);
                    next if ! $varsstr;
                    my @vars = split /\n/, $varsstr;
                    push @new_steps, $step if grep { $_ =~ $varexpr } @vars;
                }
                @steps = @new_steps;
            }
            # Only steps with tag matching a regular expression.
            when ("tre")
            {
                my $tagexpr = get_eman_select_arg(\@args);
                my @new_steps;
                for my $step (@steps)
                {
                    my $tagsstr = compiled_tag_string($step);
                    push @new_steps, $step if $tagsstr =~ $tagexpr;
                }
                @steps = @new_steps;
            }
            # Only steps that are not currently reported by qstat (in any cluster state, e.g. 'r', 'qw', 'hqw' or even 'Eqw').
            # Note that qstat is run for the current user. We do not expect the steps to run under anyone else.
            when ("nq")
            {
                my @qjobids = grep {m/^\d+$/} split(/\n/, `qstat | cut -d' ' -f1`);
                # We will not rely on step guessing from job id. A step may have more than
                # one job id if it is re-run and reindexing is needed to get the current one.
                # This command is intended to identify jobs that failed to fail correctly.
                # It would be dangerous to draw conclusions from not finding a job just because
                # we do not know its current job id. (Possible conclusions include destroying the step.)
                @steps = grep {
                    my $found = 0;
                    my $emanjobid = `cat $_/eman.jobid`;
                    $emanjobid = 0 if($emanjobid !~ m/^\d+$/);
                    foreach my $qjid (@qjobids)
                    {
                        if (-f "$_/log.o$qjid" || $emanjobid == $qjid)
                        {
                            $found = 1;
                            last;
                        }
                    }
                    !$found
                } @steps;
            }
            # Only steps that have at least one following step ("user") with given properties.
            # The remaining filtering commands define the following step searched for.
            # If there are no remaining commands, the steps with at least one user will be selected.
            when ("u")
            {
              @steps = grep {
                my @users = keys %{ $idx->{'USED_BY'}->{$_} };
                filter_steps(\@users, @args);
              } @steps;
              splice(@args); # already used to filter the user-steps
            }
            # only remote/subdir steps
            when ("remote")
            {
              guess_maindir();
              @steps = grep { ! -d "$maindir/$_" } @steps;
              $remote = 1;
            }
            # only steps created on given date (YYYYMMDD)
            when ("date")
            {
              my $date = get_eman_select_arg(\@args);
              @steps = grep { $date == get_step_date($_) } @steps;
            }
            # steps created today
            when ("today")
            {
              my $today = `date '+%Y%m%d'`;
              @steps = grep { get_step_date($_) == $today } @steps;
            }
            # backward recursion: steps which have a predecessor with given
            # properties
            when ("br")
            {
              # generator function provides step dependencies
              @steps = grep {
                recfilter(
                  $_,
                  sub { return filter_steps($_[0], @args) },
                  \&load_depsarr)
              } @steps;
              splice @args;
            }
            # forward recursion: steps which have a successor with given
            # properties
            when ("fr")
            {
              # generator function provides step users
              @steps = grep {
                recfilter(
                  $_,
                  sub { return filter_steps($_[0], @args); },
                  sub { return [ keys %{ $idx->{'USED_BY'}->{$_[0]} } ]; })
              } @steps;
              splice @args;
            }
            # Unknown filter command.
            default
            {
                # Die the same way as if missing required argument.
                get_eman_select_arg([]);
            }
        }
    }
    print STDERR "Survived: ", join(" ", @steps), "\n" if $debug;
    return @steps;
}

# given a step, a filter function and a function to generate new steps
# (e.g. step dependencies or users), return 1 if any of the generated steps
# (recursively) satisfes the filter
sub recfilter {
  my $step = shift;
  my $filter = shift;
  my $generator = shift;

  my $generated = $generator->($step) // [];
  return $filter->($generated) ||
    grep { recfilter($_, $filter, $generator) } @$generated;
}

sub select_steps {
  my @args = @_;
  my @steps = grep { $_ !~ m/(jid|path)/ } all_steps();
  @steps = filter_steps(\@steps, @args);
  if ($steps[0]) {
    # all_steps() could have returned also NONEXISTENT steps (missing folder but the step mentioned as a dependency of another step).
    # list() will die on NONEXISTENT steps ("Failed to guess step from: s...")
    # Thus remove NONEXISTENT steps now.
    @steps = grep { defined get_stepdir($_) } @steps;
    if (!scalar @steps) {
      return 1;
    }
    return list([@steps]);
  } else {
    return 1;
  }
}

sub do_outdate {
  my $step = shift;
  my $olddir = chdir_to_stepdir($step);
  if ($dryrun) {
    print STDERR "Not outdating $step in --dry-run.\n";
  } else {
    # perhaps should not outdate abolished steps?
    save("eman.status", "OUTDATED");
  }
  mychdir($olddir);
}

sub add_dir {
  my $dir = shift;
  mydie "No directory given." if ! $dir;
  if (-e $dir) {
    mydie "$dir is not a directory" if ! -d "$maindir/$dir";
  } else {
    mkpath($dir);
    mydie "Failed to create directory: $dir" if ! -d "$maindir/$dir";
  }
  my @current = split /\n/, try_load("$maindir/$subdirs_file");
  $dir = abs_path($dir);
  return if grep { $_ eq $dir } @current; # do not add dirs multiple times
  open(my $subdirs_hdl, ">>$maindir/$subdirs_file") or mydie "Cannot open $maindir/$subdirs_file";
  print $subdirs_hdl $dir, "\n";
  close $subdirs_hdl;
}

sub add_remote_playground {
  my $dir = shift;
  my $alias = shift;
  mydie "Usage: eman addremote DIR ALIAS" if ! $dir || ! $alias;
  mydie "$dir is not a directory" if ! -d $dir;
  mydie "$dir is not an eman playground" if ! -d "$dir/$seedsdir";
  mydie "$alias already exists" if -e "$maindir/$alias";
  my @current = split /\n/, try_load("$maindir/$subdirs_file");
  my $absdir = abs_path($dir);
  my @identical = grep { abs_path($_) eq $absdir } @current; # do not add dirs multiple times
  mydie "Remote $identical[0] points to the same location" if defined $identical[0];
  symlink abs_path($dir), "$maindir/$alias";
  open(my $subdirs_hdl, ">>$maindir/$subdirs_file") or mydie "Cannot open $maindir/$subdirs_file";
  print $subdirs_hdl "$maindir/$alias\n";
  close $subdirs_hdl;
}

sub try_load {
  my $f = shift;
  my $h = try_open($f);
  return undef if !defined $h;
  my $o = "";
  $o .= $_ while (<$h>);
  close $h;
  chomp $o;
  return $o;
}
sub load {
  my $f = shift;
  my $h = my_open($f);
  my $o = "";
  $o .= $_ while (<$h>);
  close $h if $f ne "-";
  chomp $o;
  return $o;
}
sub save {
  my $f = shift;
  my $data = shift;
  my $h = my_save($f);
  print $h $data;
  print $h "\n" if $data ne "" && $data !~ /\n$/m;
  close $h;
}
sub append {
  my $f = shift;
  my $data = shift;
  my $h = my_save($f, "do-append");
  print $h $data;
  print $h "\n" if $data ne "" && $data !~ /\n$/m;
  close $h;
}

sub try_open {
  my $f = shift;
  if ($f eq "-") {
    binmode(STDIN, ":utf8");
    return *STDIN;
  }

  return undef if ! -e $f;

  my $opn;
  my $hdl;
  my $ft = `file $f`;
  $ft = "" if ! defined $ft;
  # file might not recognize some files!
  if ($f =~ /\.gz$/ || $ft =~ /gzip compressed data/) {
    $opn = "zcat $f |";
  } elsif ($f =~ /\.bz2$/ || $ft =~ /bzip2 compressed data/) {
    $opn = "bzcat $f |";
  } else {
    $opn = "$f";
  }
  open $hdl, $opn or return undef;
  binmode $hdl, ":utf8";
  return $hdl;
}
sub my_open {
  my $f = shift;
  if ($f eq "-") {
    binmode(STDIN, ":utf8");
    return *STDIN;
  }

  confess "Not found: $f" if ! -e $f;

  my $opn;
  my $hdl;
  my $ft = `file $f`;
  $ft = "" if ! defined $ft;
  # file might not recognize some files!
  if ($f =~ /\.gz$/ || $ft =~ /gzip compressed data/) {
    $opn = "zcat $f |";
  } elsif ($f =~ /\.bz2$/ || $ft =~ /bzip2 compressed data/) {
    $opn = "bzcat $f |";
  } else {
    $opn = "$f";
  }
  open $hdl, $opn or confess "Can't open '$opn': $!";
  binmode $hdl, ":utf8";
  return $hdl;
}

sub my_save {
  my $f = shift;
  my $do_append = shift;
  my $appendop = $do_append ? ">" : "";
  my $opn;
  my $hdl;
  if ($f =~ /\.gz$/) {
    $opn = "| gzip -c >$appendop $f";
  } elsif ($f =~ /\.bz2$/) {
    $opn = "| bzip2 >$appendop $f";
  } else {
    $opn = ">$appendop $f";
  }
  mkpath( dirname($f) );
  open $hdl, $opn or confess "Can't write to '$opn': $!";
  binmode $hdl, ":utf8";
  return $hdl;
}

# from Perl Cookbook:
# http://docstore.mik.ua/orelly/perl4/cook/ch06_10.htm
sub glob2pat {
  my $globstr = shift;
  my %patmap = (
    '*' => '.*',
    '?' => '.',
    '[' => '[',
    ']' => ']',
  );
  $globstr =~ s{(.)} { $patmap{$1} || "\Q$1" }ge;
  $globstr =~ s/\\-/-/g;
  return '^' . $globstr . '$';
}

sub lightglob {
  my ($wildcard, $current) = @_;
  $current = "/" if ! $current;
  print STDERR "lightglob($wildcard, $current)\n" if $debug;
  $wildcard =~ s#/?([^/]*)/?(.*)#$2#;
  my $pattern = glob2pat($1);
  opendir(my $dh, $current) or confess "Failed to open dir: $current";
  print STDERR "Regex pattern: $pattern\nReading $current... " if $debug;
  my @list = grep { $_ =~ m/^$pattern$/ } readdir $dh;
  if ($wildcard) {
    @list = map { lightglob($wildcard, "$current/$_") if -d "$current/$_" } @list;
  }
  print STDERR "Found ", scalar(@list), " matches\n" if $debug;
  closedir $dh;
  return map { "$current/$_" } @list;
}

sub safesystem {
  print STDERR "Executing: @_\n";
  return quietsystem(@_);
}
sub quietsystem {
  system(@_);
  if ($? == -1) {
      print STDERR "Failed to execute: @_\n  $!\n";
      exit(1);
  }
  elsif ($? & 127) {
      printf STDERR "Execution of: @_\n  died with signal %d, %s coredump\n",
          ($? & 127),  ($? & 128) ? 'with' : 'without';
      exit(1);
  }
  else {
    my $exitcode = $? >> 8;
    print STDERR "Exit code: $exitcode\n" if $exitcode;
    return ! $exitcode;
  }
}

sub field {
  my $l = shift;
  my $i = shift;
  chomp $l;
  my @f = split /\t/, $l;
  return $f[$i];
}

sub var_bash_escape {
  my $s = shift;
  return $s if $s =~ /^[-[:alnum:]:._+,]*$/;
  $s =~ s/\\/\\\\/g;
  $s =~ s/"/\\"/g;
  return '"'.$s.'"';
}

sub var_bash_unescape {
  # the reverse of *our* escaping, not all possible escaping
  my $s = shift;
  return $s if $s !~ /^"/;
  $s =~ s/^"//;
  $s =~ s/"$//;
  $s =~ s/\\(["\\])/$1/g;
  return $s;
}


__END__

=head1 eman

eman, experiment manager

=head1 SYNOPSIS

  VAR=val eman init STEPTYPE # create new step of the given type
  VAR=val eman clone SPEC    # create new step based on SPEC

  eman clone < traceback     # create step by cloning incl. predecessors
  eman redo EXPSPEC          # equals 'eman tb --vars SPEC | eman clone'
                             # good predecessors are reused by default
    --reuse=SPEC             #   reuse the given step (incl. predecs.)
    --ignore=STEPTYPE        #   reuse steps of the given type
    --avoid=SPEC             #   don't reuse the given step in the clone
    --redo=STEPTYPE          #   don't reuse any steps of the given type
    --all-avoid              #   avoid all input steps
    --start                  # after init/clone/redo, submit to queue

  eman prepare SPEC          # prepare inited step
  eman run SPEC              # run prepared step
  eman continue SPEC         # continue a single step that failed
  eman clean SPEC            # erase files other than eman* and log* to make
                             # the step reentrant and 'eman continue' safe
  eman start EXPSPEC         # prepare and run, incl. all predecessors
    --priority -200          #   cluster scheduling priority (default: -100)
    --mem 15g                #   required memory (default: 6g)
    --disk 20g               #   required space in /mnt/h/tmp
    --cores 4                #   number of cores to use

  eman guess SPEC            # guess a *single* step based on the jobid
                             # or a substring of the hash, the tag, the
                             # date or final score
  eman qstat                 # call SGE's qstat and guess steps for eman jobs

  eman list STEPTYPE ...     # list all steps of the given type
  eman status SPEC/STEPTYPE  # like 'list --status', abbr. 'stat'
  eman vars SPEC/STEPTYPE    # like 'list --vars'
  eman tag SPEC/STEPTYPE     # like 'list --tag'
  eman annotate <txt >txt    # adds --stat, --tag, ... after stepname
  eman users SPEC ...        # list all steps that use the given step
  eman traceback EXPSPEC ... # show tree of the steps and predecessors
    --tag --vars --status    #   include extra information
                             #   tracebacks with --vars fully specify
                             #   the experiment
    -s /foo/bar/             #   modify vars; can be repeated
                             #     implies --vars
                             #     highlights diff if to terminal
    -sv VAR=newvalue         #   use -s to set the given VAR; can be repeated
    --ignore STEPTYPE        #   do not include STEPTYPE in traceback
  eman traceforward EXPSPEC  # show tree of the steps and users (successors)
  eman duplicates            # show groups of 2+ steps having same vars
    --tag --vars --status    #   include relevant information
    --log --jobid            #   and the tail of the log or SGE job ID

  eman abolish SPEC ...      # destroy all step files except
                             #   metadata => can still be cloned
  eman collect               # collect results of all experiments
  eman reindex               # re-create index of steps

  eman wait SPEC ...         # block until the jobs are FAILED or DONE
                             # die if FAILED or DONE is not reachable

  eman select QUERY          # output steps matching the QUERY;
                             #   query syntax is documented below

  eman addremote DIR ALIAS   # add a remote eman playground as ALIAS
                             # you can use remote steps, clone them etc.
  eman adddir DIR            # add a subdirectory for steps

SPEC is a step specifier, i.e. a text snippet capable of identifying a step
uniquely. This can be a full stepdir name such as
's.align.12345678.20121010-1010' or any sufficient portion of it such as
'678.2013'. You can even use '.' and '`pwd`' as SPEC. And once results are
collected, any unambigous result number can be also used to refer to the
respective step directory.

EXPSPEC is an experiment specifier. Formally, EXPSPEC and SPEC are identical,
they refer to a particular unambiguous step directory. The difference lies in
the command itself: SPEC-commands operate on the single step directory while
EXPSPEC-commands operate on the whole structure of the step and its
predecessors.

STEPTYPE specifies the seed to be used, e.g. 'align'.


=head1 DESCRIPTION

Command aliases:

  abolish      rm
  clone        cl
  continue     cont
  duplicates   dups
  list         ls
  prepare      pr
  prepare      prep
  retag        retag
  select       sel
  start        st
  status       stat
  tabulate     tab
  traceback    tb
  traceback    tr
  traceforward tf
  traceforward traceusers
  traceforward tu

Eman is an experiment manager, useful mainly for deriving steps and
step chains, i.e. complex experiment scenarios.

In the following:

 a step        ... is a single unit of work
 an experiment ... is a directed acyclic graph (DAG) of depending steps.
                   an experiment can be also called a workflow.
                   eman currently displays DAGs as trees, repeating
                   shared steps
 a step seed   ... is a recipe to build individual steps

=head2 Why Should You Use eman?

Eman is designed to speed up your 'experimental loop' and broaden the range of
explored experiment configurations while maintaining the reproducibility of all
the various experiment runs. The specific subject of your experiments is not
important for eman---all commands to run etc. are encoded in your custom
'seeds'.

=head2 Structure of a Step Directory

Each step is represented as a single directory s.STEPTYPE.HASH.TIMESTAMP.
Apart from any files needed or produced by the step, the following files are
always present in the step directory:

 *eman.tag           ... one-line "readable" summary of vars
                         Often manually edited to contain special flags.
 #eman.vars          ... the variables configuring the step
 *eman.deps          ... list of prerequisites of this step
 *eman.status        ... the status of the step
  eman.jobid         ... the jobid of the most recent (re)run
  eman.seed          ... the script used to init and prepare the step
 #eman.command       ... the script used to run the step
  eman.derived_from  ... the name of the step used when deriving
  eman.init_env      ... all environment variables at init time

Files marked with '#' have to be provided by your 'seed' scripts. Files marked
with '*' can be provided by your 'seed' scripts. Other files are created by
eman.

=head2 Special Files in Directory of Steps

In the directory containing all your steps, eman uses the following files:

 #eman.seeds         ... the directory of all step seeds
  eman.index         ... index of steps for quick check for identities
 #eman.results.conf  ... name wildcard pattern and regex to extract result
  eman.results       ... collected results from all steps

Again, you are responsible for providing the items marked '#'.

=head2 Life Cycle of Individual Steps

Each (successful) step goes through these core phases:

  init    ... become part of structure of experiments, depend on other
              steps and allow other steps depend on me
  prepare ... quickly check that all input files exist
  run     ... long computation, submitted to cluster

Other than that, steps are considered immutable. You can modify
existing steps as you like (changing status, variables, contents) but
you are sacrificing the reproducibility of your experiments. Our best
practice involves a lot of hacking of existing steps in early stages of
implementation interleaved with frequent cloning and reruning of the
experiments from scratch. Later, once all new tweaks are exposed as
variables of the respective steps, we absolutely avoid modifying
existing steps and use cloning only.

The progress of a step is achieved by eman following this procedure:

1. The commands 'eman init STEPTYPE' and 'eman clone s.STEPTYPE....'
create a timestamped step directory, e.g. s.test.hash1234.20101115-1213.

2. The file eman.seeds/STEPTYPE is copied there as eman.seed.

3. The seed is run and expected to 'init' (i.e. produce the file
eman.vars and optionally eman.deps). The seed may also produce
eman.status with the content 'DONE' or 'PREPARED' to skip some of the
following phases (XXX unimplemented). By default, the status becomes
'INITED'.

4. The seed is run and expected to 'prepare' (i.e. produce the file
eman.command). The status becomes 'PREPARED'.

5. eman.command is run and expected to write 'DONE' or 'FAILED' to
eman.status.

The following statuses are recognized:

  NONEXISTENT        ... not created yet / irreversibly deleted
  INITED             ... the step was just created
  INITFAILED         ... the initialization failed
  PREPARED           ... prepared using 'eman prepare'
  PREPFAILED         ... 'eman prepare' failed
  WAITING: ...       ... submitted by 'eman start', prereqs still run
                         (not used; waiting jobs are marked 'running')
  STARTING           ... just before 'running'
  RUNNING            ... running
  FAILED             ... the run failed
  DONE               ... the run succeeded
  ABOLISHED          ... has just vars, deps but no more content
  OUTDATED           ... you can manually set this to prevent reuse

=head1 STEP AND EXPERIMENT CLONING

The support for cloning steps and whole experiments (sequences of steps)
is a key feature of eman. Cloning could be also called 'deriving',
because we allow the clone to bear different variable values.

Cloning a step (the command 'eman clone SPEC') means creating a
completely new step and providing it with variables from the source
step and possibly adding or modifying some.

Cloning a sequence of steps (the commands 'eman clone < traceback' and
'eman redo') is slightly trickier: imagine we change a variable in an
early step in the sequence. All the following steps in the experiment
then have to be instructed to use this modified step. Eman achieves this
by explicitly replacing the original step name with the name of the new
step in variables of subsequent steps. The immutability of steps
naturally requires to clone the subsequent steps as well.

=head1 FINDING STEPS

Once you have many complex experiments in your playground, using 'ls'
becomes less friendly. Eman can provides a few tools to locate
experiments matching you criteria.

While direct access of the filesystem (ls, grep s.*/eman.vars, ...) is
perhaps faster, it does not search in (remote) subdirs of your
playground.

  eman ls STEPTYPE  ... just lists existing steps
  eman select QUERY-ARGUMENTS

=head2 Eman `select' Query Syntax

You can use the following filters in eman select:

  t <type>         ... only steps of type <type>
  l <count>        ... latest <count> steps
  lh               ... latest 10 steps
  d                ... only DONE steps
  f                ... only FAILED steps
  r                ... only RUNNING steps
  p                ... only PREPARED steps
  i                ... only INITED steps
  s <status>       ... only steps with status <status>
  v <VAR>=<value>  ... only steps with variable <VAR> that
                       has value <value>
  vre <regex>      ... only steps where the variable matches <regex>
                       (the expression can contain the name of the variable)
  tre <regex>      ... only steps where tags (incl. autotags) match <regex>
  nq               ... only steps not currently known to qstat
                       (current user, any cluster job status)
  u <criteria>     ... only steps that have at least one user with given
                       properties; rest of query defines the user
  br <criteria>    ... only steps that have at least one (transitive) predecessor
                       with given properties (backward recursion)
  fr <criteria>    ... only steps that have at least one (transitive) successor
                       with given properties (forward recursion)
  not              ... negation of the remaining filters
                       e.g. eman select not d
  remote           ... only remote steps
  date <date>      ... only steps created on <date> (yyyymmdd)
  today            ... only steps created today

Examples:

  eman sel t mert d                        # MERT steps that are DONE
  eman sel lh                              # last 10 steps
  eman sel t tm v DECODINGSTEPS=t0-0       # tm steps with one 1-factor t-step
  eman sel t tm vre '^DECODINGSTEPS=t0-0$' # equvivalent to the above
  eman sel t mert br vre 'ALIAUG.*lcstem4' # MERT steps where word alignment
                                           # was done on lcstem4

  # The result (and speed) depends on the order of filters, e.g.:
  eman select t mert l 10 # output last 10 merts
  eman select l 10 t mert # output merts that were among 10 latest steps

=head1 USAGE PATTERNS

  eman traceback SPEC -s '/.../.../'
  # preview the experiment with some vars replaced
  # append "--colorize | less" to preview

  eman traceback SPEC -s '/.../.../' | eman clone
  # clone the whole subtree of steps replacing some vars

  VAR=x eman redo SPEC
  # clone the top step (and unusable predecessors) replacing VAR
  # with some new value x

  eman redo SPEC --start --outdate
  # redo all failed/outdated steps, mark them as outdated

  eman td SPEC --stat
  # see what all was derived (by redo or clone) from SPEC
  # useful e.g. for chasing redone experiments and finding the last one

  eman annotate --stat < my-notes.txt > new-notes.txt
  # change "s.anything.123 (anything)" into "s.anything.123 (RUNNING)"
  # useful for making your notes up-to-date

  eman abolish `eman select t STEPTYPE f`
  # remove all content files of all failing steps of a STEPTYPE

  eman stat `qstat | cut -c 1-8 | skip 2`
  # show status of all running/held jobs in SGE
  # WARNING: This only works if there are no non-eman cluster jobs.
  # Otherwise, eman will just say "Failed to guess step from: $job_id".
  # the skip command is available here:
  #   http://www.cuni.cz/~obo/textutils/#skip

  eman sel t MERT fr t EVAL tre FOO
  # list all MERT steps that were used to construct EVAL steps tagged
  # with the tag FOO

  eman sel t lm vre tag --stat --vars | grep 'ORDER\|s.lm'
  # what all orders of LM do I have over morphological 'tag's

  eman select r nq
  # which failed jobs failed to fail correctly?
  # eman believes they are still running but cluster does not know them

  eman sel t evaluator br t lm vre 'CORP.*=MYCORPUS'
  # all 'evaluator' steps which use a language model trained on MYCORPUS

  eman sel t tm not fr t evaluator
  # all 'tm' steps which have not been evaluated (i.e. not step of type
  # 'evaluator' transitively depends on them)

  eman sel f br vre 'ALICORP=.*un.*'
  # list all failed steps depending (transitively) on ALICORP=*un*
  # (e.g. un.fr-en or un.es-en)

  eman select t translate not u t evaluator
  # list all translate steps whose users (intransitive) do not include any
  # evaluator step

  eman ls > steps-all.txt
  eman traceback --notree \
    `qstat | grep $USER | grep -P '\ss\.' | cut -d' ' -f1 | grep -v 4296093` \
    | sort -u > steps-tabu.txt
  perl -e '
    open(TABU, "steps-tabu.txt") or die;
    while(<TABU>) { $tabu{$_}++ }
    open(ALL, "steps-all.txt") or die;
    while(<ALL>) { print unless($tabu{$_}) }' > steps-free.txt
  for i in `cat steps-free.txt` ; do
    echo $i ; cp -r $i /net/cluster/TMP/$USER/new_playground
  done
  for i in `cat steps-free.txt` ; do echo $i ; rm -rf $i ; done
  # I want to move the playground to another disk because I am hitting the
  # quota. But I need to know first which steps are running or prerequisities
  # of something running (immovable at the moment). Note the "grep -v 4296093"
  # above. Eman will die if any of the running jobs don't match a known step.
  # (BEWARE: Copying steps will also separate numerous hardlinks we have there.
  # The target disk usage will be much higher until we rejoin the hardlinks
  # again or erase them.)

=head2 If a Cluster Node Completely Dies

A cluster node completely dies when (your) job takes too much RAM. Assuming
2472256 is the SGE job ID of the failed (but still allegedly running) job, this
is probably what you want to do:

  qdel 2472256                         # remove it from the cluster
  eman fail 2472256                    # mark it FAILED for eman
  eman redo 2472256 --start --mem 20g  # clone and re-run it with some more memory\
# or:
  eman continue 2472256 --mem 20g      # re-run it with more memory
    # eman redo will clone the failed step (and reuse steps it depends on)
    # eman continue will rerun the original step instead (run eman.command
    # without generating it anew); note that running users of the step cannot
    # be saved like this (run eman redo on the last step afterwards)

=head1 COMMON PROBLEMS

=head2 Outdated Index File

If you run e.g. 'eman users ...', get a step directory, but subsequent eman
commands fail to find it ("Failed to guess step from:..."), try running:

  eman reindex

The step may indeed be a zombie, a removed directory.

=head2 Multiple Step Instances, Some Failed, Some OK

By cloning, you can easily end up with several instances of the same step (i.e.
two distinct step directories with identical variables). Sometimes, some of the
instances may be even failed and some may be finished successfully.

When such a step is
further used in an experiment, and you clone the experiment, eman will
automatically use the oldest plausible instance (FAILED, OUTDATED and ABOLISHED
instances are not considered plausible).

To pick a specific instance of a step manually (including implausible
instances), use --reuse. To avoid some instances, use --avoid.

You may wish to use 'eman dups' every now and then to get rid (or abolish) some
of the unused instances.


=head1 WRITING SEEDS: CORE CONVENTIONS

Seeds (in eman.seeds) have to follow some conventions.

- executable

- respond to environment variables

- exit code 0 for success, other for failure

- init and prepare by default

- init only if $INIT_ONLY==yes

=head2 When Initing

- create the file: eman.vars

- optionally also create: eman.tag, eman.deps

Note that for reliable cloning, deps must be directly determined from
the vars. It is actually best to include the full name of the dependence
in one of the variables.

=head2 When Preparing

- create the file: eman.command

=head1 WRITING SEEDS: TIPS

=head2 Inheriting Variables

It is often useful to propagate a value of a variable from a dependence to the
current step. This can be easily achieved:

  INHERITED=`cat ../$DEPENDENCE/eman.vars | grep TO_INHERIT | cut -d= -f2`
  echo INHERITED=$INHERITED >> eman.vars # save as our variable

Note that your seed can be asked to perform the init before the $DEPENDENCE was
prepared and likewise, it can be asked to prepare before $DEPENDENCE was run.
So avoid asking for files in $DEPENDENCE too early.

Note DZ: The complicated code above is probably outdated.
There is now support for variable inheriting directly in eman.
This is an example of what to include in the seed of the inheriting step:

  eman defvar INHERITED inherit=PREVIOUSSTEP
  eman defvar INHERITED2 inherit=PREVIOUSSTEP:VARIABLE


=head2 Inheriting Dependencies

Consider the following traceback:

  +- s.tm.ABC.20101127-1856
  |  | ALIGN=s.align.DEF.20101127-1856
  |  | BINARIES=s.binaries.GHI.20101127-1856
  |  +- s.align.DEF.20101127-1856
  |  |  | BINARIES=s.binaries.GHI.20101127-1856
  |  |  +- s.binaries.GHI.20101127-1856
  |  +- s.binaries.GHI.20101127-1856

The step 'binaries' is used by 'tm' directly but could be 'inherited' from
'align', so that we don't have to specify it when initing 'tm' and also the
traceback is simpler:

  +- s.tm.ABC.20101127-1856
  |  +- s.align.DEF.20101127-1856
  |  |  +- s.binaries.GHI.20101127-1856

The best technique to achieve this simplification is:

1. 'align' should have BINARIES as a variable as well as a dependence.

2. 'tm' should have BINARIES only as a variable and not as a dependence.

3. The seed of 'tm' should use the given ALIGN to copy BINARIES from there.

4. For best flexibility, 'tm' should allow for using a different 'binaries'
step. If and only if this happens, 'tm' should add the extra dependence:

  +- s.tm.ABC.20101127-1856
  |  | ALIGN=s.align.DEF.20101127-1856
  |  | BINARIES=s.binaries.JKL.20101130-1100
  |  +- s.align.DEF.20101127-1856
  |  |  | BINARIES=s.binaries.GHI.20101127-1856
  |  |  +- s.binaries.GHI.20101127-1856
  |  +- s.binaries.GHI.20101120-1100

Here a is proposed bash solution for the 'tm' seed:

  INHERITED=`cat ../$ALIGN/eman.vars | grep BINARIES | cut -d= -f2`
  if [ -z "$BINARIES" ] || [ "$BINARIES" == "$INHERITED" ]; then
    # inheriting
    BINARIES=$INHERITED
  else
    # using our own
    echo $BINARIES >> eman.deps
  fi
  # surely store the var
  echo BINARIES=$BINARIES >> eman.vars

The topic of inherited dependencies is related to the question whether we see
the experiment as a tree or a directed acyclic graph.

=head1 FUTURE EXTENSIONS

=head2 eman.requests

A script in step directory that will, based on the size of step's data etc.,
predict the requirements on disk and memory and output a string such as:

  --mem 30g --disk 100g

The output would be used as additional arguments for eman start/continue.

The script would be optional and command-line specified parameters would
override its output.

=head1 SEE ALSO

Eman is somewhat similar but also different from other experiment managements
systems.

While other experiment management systems treat the whole experiment
as the main goal (allowing to represent variations within the experiment and
reusing parts of previous experiment runs), eman works primarily with the
individual steps. The complete experiments emerge rather as side-effects.
Later, they can be easily displayed using 'eman traceback' as well as reused or
modified using 'eman clone|redo'. We like to say that this make eman more
flexible.

Essentially, an eman traceback can be seen as a sample workflow and 'eman clone
< traceback' can be used to instantiate the workflow.

A feature very natural for eman but still unique compared to other systems is
the command-line interface to construct variations of steps or experiments. The
exploration of the space of configurations can thus be quickly automated.

Related experiment or workflow management systems:

=head2 LoonyBin

  http://www.cs.cmu.edu/~jhclark/loonybin/

LoonyBin is a clickable Java tool. The good sides of LoonyBin are: support
for multiple clusters and schedulers.

=head2 Moses Experiment Management System

  http://www.statmt.org/moses/?n=FactoredTraining.EMS

Moses EMS (experiment.perl) is centered around a single (customizable)
experiment which consists of steps.

=head2 Other

There are also the following workflow management systems: DAGMan, Pegasus,
Dryad.

=head1 AUTHOR

Ondřej Bojar <obo@matfyz.cz>

Contributions by Aleš Tamchyna and Dan Zeman.

Copyright 2010-2013, the respective authors. All rights reserved.

=cut
